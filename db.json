{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/bbb.jpg","path":"img/bbb.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":0},{"_id":"source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/My-hobby.md","hash":"2cd64cd7fec9df0b9974b4249ad5988dfa911d8a","modified":1634145617023},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1630641855571},{"_id":"source/_posts/hexo使用指南.md","hash":"9cf632a76c09338f38ee34db0f91b6d5b54f72f7","modified":1636306779081},{"_id":"source/_posts/test.md","hash":"dd0098d0442bd552604556131663d44166e8e16e","modified":1634145910521},{"_id":"source/_data/link.yml","hash":"fe7d2f70f7a629ed1b0d33d69cb4ce4411506fe5","modified":1630631795322},{"_id":"source/about/me.md","hash":"9abd4731f21cee77b4e38c23fa37a82adf90e694","modified":1636306452087},{"_id":"source/categories/index.md","hash":"0c13fa645e6b99da21a4077d7af18109400025a9","modified":1636306677026},{"_id":"source/img/avatar.jpg","hash":"e51b261d9c3b6f00e7f70624510fd0c3eb69f80f","modified":1629169926190},{"_id":"source/img/hexo_guid_1.PNG","hash":"8fbdfca9ff92e636018d1a7c7577f4ddb7e8eac4","modified":1634146296431},{"_id":"source/img/hexo_guid_file_tree.PNG","hash":"65af47cf0130a3c0fe1e4ab60585303e5f123d51","modified":1634146493207},{"_id":"source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1630303130000},{"_id":"source/tags/index.md","hash":"f7efac5ed7c7000d64dc809f9d8bdbe223039de4","modified":1636306151162},{"_id":"source/link/index.md","hash":"1aa51035d00b668d0261db95063d572d2756c976","modified":1636306141497},{"_id":"source/img/bbb.jpg","hash":"2810ef370935fc2e460e05180647dbea11093a22","modified":1608370688509},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"63d1a594969b7b5b97e1babebc7b85ef07c02e4f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"1b859b6d3f6063ce107d61c38f4011458e74b143","modified":1630629119084},{"_id":"node_modules/hexo-theme-butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":499162500000},{"_id":"source/img/bg.jpg","hash":"47501d9ab2e610dcbfe12830f599dba46056af74","modified":1630629367154},{"_id":"public/about/me.html","hash":"49429bc05d43ea8f2dae24e56f8ff12becd54630","modified":1636306460627},{"_id":"public/categories/index.html","hash":"ace35552690c7ff06d18f9218f7c9b080f23dad1","modified":1636392059152},{"_id":"public/link/index.html","hash":"820258274239ead768b00cbd578971e60202ac3d","modified":1636392059152},{"_id":"public/2021/10/14/hexo使用指南/index.html","hash":"6532f24872b198d145135e61176ee748ceaa5ca4","modified":1636391769605},{"_id":"public/tags/index.html","hash":"bba1e499166ac1169ea1d4451cbbb1cd660529fa","modified":1636392059152},{"_id":"public/2021/10/14/test/index.html","hash":"959ac4e310fe666774fc56b0b0cd0e4e677b7c85","modified":1634147736765},{"_id":"public/2021/09/03/hello-world/index.html","hash":"b08e9742f7ed425cf92d05f8fb396f4cd53cbe68","modified":1636391769605},{"_id":"public/2021/09/03/My-hobby/index.html","hash":"0dd2080fe15f039843bf5fef2a19f00f8f3043b3","modified":1634147736765},{"_id":"public/archives/index.html","hash":"dd4b2a11f619df8f4a3a41b114e3322b6d9b81c2","modified":1636392059152},{"_id":"public/archives/2021/index.html","hash":"1b819f5618a22687a22e51b863748b98922e6448","modified":1636392059152},{"_id":"public/archives/2021/09/index.html","hash":"67cd8f143b76e9c238f46a48abde4135c1e2eddb","modified":1636392059152},{"_id":"public/archives/2021/10/index.html","hash":"a6ab05d1c75c2e758a534e97faaa86c28560b658","modified":1636392059152},{"_id":"public/tags/tools/index.html","hash":"68439173eddbca199d7539f83ebb29543f09005c","modified":1636306460627},{"_id":"public/index.html","hash":"d3807bccabd8b8d67088a302dbe31c49e7e14cbb","modified":1636392059152},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1634147736765},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1634147736765},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1634147736765},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1634147736765},{"_id":"public/img/avatar.jpg","hash":"e51b261d9c3b6f00e7f70624510fd0c3eb69f80f","modified":1634147736765},{"_id":"public/img/hexo_guid_1.PNG","hash":"8fbdfca9ff92e636018d1a7c7577f4ddb7e8eac4","modified":1634147736765},{"_id":"public/img/hexo_guid_file_tree.PNG","hash":"65af47cf0130a3c0fe1e4ab60585303e5f123d51","modified":1634147736765},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1634147736765},{"_id":"public/img/bbb.jpg","hash":"2810ef370935fc2e460e05180647dbea11093a22","modified":1634147736765},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1634147736765},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1634147736765},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1634147736765},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1634147736765},{"_id":"public/css/index.css","hash":"55e16a3189b3c612a30d393d37575c6cf8675dec","modified":1634147736765},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1634147736765},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1634147736765},{"_id":"public/img/bg.jpg","hash":"47501d9ab2e610dcbfe12830f599dba46056af74","modified":1634147736765},{"_id":"source/_posts/system.md","hash":"90f3519336f7482462ec1f68365377edc5845d72","modified":1636306038730},{"_id":"public/2021/11/08/system/index.html","hash":"0197fa4a339104cf814cb8a8f64543ac2753a94d","modified":1636391769605},{"_id":"public/archives/2021/11/index.html","hash":"84576e4d9ea57fa45b4831bf9edf600760f07af5","modified":1636392059152},{"_id":"source/about/index.md","hash":"9abd747a5f722146f3cb2f25f3cbc4c7b6a577ee","modified":1636306635153},{"_id":"public/about/index.html","hash":"f357b2bf22bc84112ad97b5364e28020e024f3f4","modified":1636392059152},{"_id":"source/_posts/c++_basic.md","hash":"71c891e539d4b6b76a23f1f30c139b414876010c","modified":1636391972860},{"_id":"public/2021/11/09/c++_basic/index.html","hash":"a541d611713223c53642fa08bf21eb46bb9b17bb","modified":1636392018048},{"_id":"public/tags/c/index.html","hash":"7c6ccf8ffe371cd207d3fdb7c51e898d18829f33","modified":1636392059152}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"categories","date":"2021-09-03T00:54:08.000Z","type":"categories","_content":"\n\n\ncategory.index \n\n","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-09-03 08:54:08\ntype: \"categories\" \n---\n\n\n\ncategory.index \n\n","updated":"2021-11-07T17:37:57.026Z","path":"categories/index.html","_id":"ckuptddvq00025opu0z7d2n7v","comments":1,"layout":"page","content":"<p>category.index </p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<p>category.index </p>\n"},{"title":"tags","date":"2021-09-03T00:53:24.000Z","type":"tags","_content":"\n\n\ntags.md??\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-09-03 08:53:24\ntype: \"tags\"\n---\n\n\n\ntags.md??\n","updated":"2021-11-07T17:29:11.162Z","path":"tags/index.html","_id":"ckuptddvt00055opu5nh6fgrp","comments":1,"layout":"page","content":"<p>tags.md??</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<p>tags.md??</p>\n"},{"title":"link","date":"2021-09-03T00:54:43.000Z","type":"link","_content":"\nlink.md ???\n","source":"link/index.md","raw":"---\ntitle: link\ndate: 2021-09-03 08:54:43\ntype: \"link\"\n---\n\nlink.md ???\n","updated":"2021-11-07T17:29:01.497Z","path":"link/index.html","_id":"ckuptddvt00065opuaf4i24fh","comments":1,"layout":"page","content":"<p>link.md ???</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<p>link.md ???</p>\n"},{"title":"About me","date":"2021-09-03T00:10:55.000Z","_content":"\n\n\n\n\n十几二十岁的年纪, 我们会被那些深深刻在基因里的*情欲折磨*得不轻, 也许会做许多失智的事, 许久之后回头看, 真是悔恨。\n\n","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2021-09-03 08:10:55\n---\n\n\n\n\n\n十几二十岁的年纪, 我们会被那些深深刻在基因里的*情欲折磨*得不轻, 也许会做许多失智的事, 许久之后回头看, 真是悔恨。\n\n","updated":"2021-11-07T17:37:15.153Z","path":"about/index.html","_id":"ckvpinlyx0000d0pubbqq3u69","comments":1,"layout":"page","content":"<p>十几二十岁的年纪, 我们会被那些深深刻在基因里的<em>情欲折磨</em>得不轻, 也许会做许多失智的事, 许久之后回头看, 真是悔恨。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<p>十几二十岁的年纪, 我们会被那些深深刻在基因里的<em>情欲折磨</em>得不轻, 也许会做许多失智的事, 许久之后回头看, 真是悔恨。</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-09-03T01:27:31.405Z","updated":"2021-09-03T04:04:15.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckuptddvq00035opu37hig17x","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"hexo使用指南","date":"2021-10-13T17:46:37.000Z","_content":"\n## TODO :  图片问题还没解决   要整个服务器\n\n```\nhexo new post \"post title\"    // post是模板名字  在scaffolds文件夹里面   里面还有好多模板 \nhexo g                       // g = generate  生成静态文件\nhexo s\t\t\t\t\t  // s = server  在本地开启端口 浏览器 http://localhost:4000/ 走起\nhexo g -d                 //  d = deploy   配置好直接push到github上去   具体配置不记得了 \n```\n\n\n\nas you can see.  \n\npublic 是生成后的静态文件     scaffolds是模板文件  可以用 hexo new post \"title\" 去生成相应的markdown文件 \n\nsource 是markdown源文件   hexo基于此生成的静态网页   _config.yml 是配置文件  可以整很多花样  \n\n\n参考 \n\n[hexo.io](https://hexo.io/zh-cn/docs/writing)\n\n[butterfly.js](https://butterfly.js.org/)\n\n[youtube](https://www.youtube.com/watch?v=HLJ9jJy7CMg)\n\n\n\n\n\n\n\n\n\n\n\n \n","source":"_posts/hexo使用指南.md","raw":"---\ntitle:  hexo使用指南\ndate: 2021-10-14 01:46:37\n---\n\n## TODO :  图片问题还没解决   要整个服务器\n\n```\nhexo new post \"post title\"    // post是模板名字  在scaffolds文件夹里面   里面还有好多模板 \nhexo g                       // g = generate  生成静态文件\nhexo s\t\t\t\t\t  // s = server  在本地开启端口 浏览器 http://localhost:4000/ 走起\nhexo g -d                 //  d = deploy   配置好直接push到github上去   具体配置不记得了 \n```\n\n\n\nas you can see.  \n\npublic 是生成后的静态文件     scaffolds是模板文件  可以用 hexo new post \"title\" 去生成相应的markdown文件 \n\nsource 是markdown源文件   hexo基于此生成的静态网页   _config.yml 是配置文件  可以整很多花样  \n\n\n参考 \n\n[hexo.io](https://hexo.io/zh-cn/docs/writing)\n\n[butterfly.js](https://butterfly.js.org/)\n\n[youtube](https://www.youtube.com/watch?v=HLJ9jJy7CMg)\n\n\n\n\n\n\n\n\n\n\n\n \n","slug":"hexo使用指南","published":1,"updated":"2021-11-07T17:39:39.081Z","_id":"ckuptddvv00085opu0igk353z","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"TODO-图片问题还没解决-要整个服务器\"><a href=\"#TODO-图片问题还没解决-要整个服务器\" class=\"headerlink\" title=\"TODO :  图片问题还没解决   要整个服务器\"></a>TODO :  图片问题还没解决   要整个服务器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post &quot;post title&quot;    // post是模板名字  在scaffolds文件夹里面   里面还有好多模板 </span><br><span class=\"line\">hexo g                       // g = generate  生成静态文件</span><br><span class=\"line\">hexo s\t\t\t\t\t  // s = server  在本地开启端口 浏览器 http://localhost:4000/ 走起</span><br><span class=\"line\">hexo g -d                 //  d = deploy   配置好直接push到github上去   具体配置不记得了 </span><br></pre></td></tr></table></figure>\n\n\n\n<p>as you can see.  </p>\n<p>public 是生成后的静态文件     scaffolds是模板文件  可以用 hexo new post “title” 去生成相应的markdown文件 </p>\n<p>source 是markdown源文件   hexo基于此生成的静态网页   _config.yml 是配置文件  可以整很多花样  </p>\n<p>参考 </p>\n<p><a href=\"https://hexo.io/zh-cn/docs/writing\">hexo.io</a></p>\n<p><a href=\"https://butterfly.js.org/\">butterfly.js</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=HLJ9jJy7CMg\">youtube</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<h2 id=\"TODO-图片问题还没解决-要整个服务器\"><a href=\"#TODO-图片问题还没解决-要整个服务器\" class=\"headerlink\" title=\"TODO :  图片问题还没解决   要整个服务器\"></a>TODO :  图片问题还没解决   要整个服务器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post &quot;post title&quot;    // post是模板名字  在scaffolds文件夹里面   里面还有好多模板 </span><br><span class=\"line\">hexo g                       // g = generate  生成静态文件</span><br><span class=\"line\">hexo s\t\t\t\t\t  // s = server  在本地开启端口 浏览器 http://localhost:4000/ 走起</span><br><span class=\"line\">hexo g -d                 //  d = deploy   配置好直接push到github上去   具体配置不记得了 </span><br></pre></td></tr></table></figure>\n\n\n\n<p>as you can see.  </p>\n<p>public 是生成后的静态文件     scaffolds是模板文件  可以用 hexo new post “title” 去生成相应的markdown文件 </p>\n<p>source 是markdown源文件   hexo基于此生成的静态网页   _config.yml 是配置文件  可以整很多花样  </p>\n<p>参考 </p>\n<p><a href=\"https://hexo.io/zh-cn/docs/writing\">hexo.io</a></p>\n<p><a href=\"https://butterfly.js.org/\">butterfly.js</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=HLJ9jJy7CMg\">youtube</a></p>\n"},{"title":"技术体系建立","_content":"\n### 初衷\n\n从事安卓这几年，搭建体系这个事很久就有了，可惜前期自己太懒，中期耗费了很多时间去搞其他事情。后来想了想，得回归正轨，先把技术做到专家级别，然后再去往其他方面拓展，再给我一年时间。 \n\n### 体系总览\n###### android框架层\n\n|        文章系列         | 文章数目 |        状态与备注         |\n| :---------------------: | :------: | :-----------------------: |\n|        ASOP基础         |   12篇   | 基于android 11 完成度 40% |\n| [Binder](www.baidu.com) |   3篇    | 基于android 11 完成度 20% |\n###### android应用层\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### java\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### kotlin\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### c++\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### flutter\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### python\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 设计模式\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 算法\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n* * *\n\n###### 物联网\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 音视频\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n\n### 未来要做的事\n\n#### 第一期目标:  \n|     name      |                   remark                    |\n| :-----------: | :-----------------------------------------: |\n| android框架层 | 面试的东西 binder context ams等  整理并理解 |\n| android应用层 |      架构 组件化 性能优化 各种常用框架      |\n|     java      |      oop基础  多线程  注解反射  虚拟机      |\n|    kotlin     |              语法糖 协程  函数              |\n|   设计模式    |                  源码常见                   |\n\n\n#### 第二期目标:\n|  name   |                      remark                       |\n| :-----: | :-----------------------------------------------: |\n| flutter |                  UI  调用原生sdk                  |\n|   c++   | 基础  cmake  11新特征  template  指针  内存  函数 |\n|  算法   |             leetcode-用c++去A 经典题              |\n\n\n#### 第三期目标:\n|     name     |         remark          |\n| :----------: | :---------------------: |\n| 安卓源码烧录 |   源码下载 编译 烧录    |\n|    音视频    | 入门  资源整合 编译使用 |\n\n\n#### 第四期目标:\n|         name         |             remark             |\n| :------------------: | :----------------------------: |\n|        物联网        |     智能家居 仿造  DIY自用     |\n| 常见AI模型和实际应用 | 目前已知算法实现  常见经典模型 |\n\n\n#### 第五期目标:\n| name |                        remark                        |\n| :--: | :--------------------------------------------------: |\n| 金融 | 基础  股票期货期权  贵金属  虚拟货币  交易  宏观周评 |\n| 生活 |                   做菜  健身 享受                    |\n\n","source":"_posts/system.md","raw":"---\ntitle: 技术体系建立\n---\n\n### 初衷\n\n从事安卓这几年，搭建体系这个事很久就有了，可惜前期自己太懒，中期耗费了很多时间去搞其他事情。后来想了想，得回归正轨，先把技术做到专家级别，然后再去往其他方面拓展，再给我一年时间。 \n\n### 体系总览\n###### android框架层\n\n|        文章系列         | 文章数目 |        状态与备注         |\n| :---------------------: | :------: | :-----------------------: |\n|        ASOP基础         |   12篇   | 基于android 11 完成度 40% |\n| [Binder](www.baidu.com) |   3篇    | 基于android 11 完成度 20% |\n###### android应用层\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### java\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### kotlin\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### c++\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### flutter\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### python\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 设计模式\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 算法\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n* * *\n\n###### 物联网\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n###### 音视频\n| 文章系列 | 文章数目 | 状态与备注 |\n| :------: | :------: | :--------: |\n|          |          |            |\n|          |          |            |\n\n### 未来要做的事\n\n#### 第一期目标:  \n|     name      |                   remark                    |\n| :-----------: | :-----------------------------------------: |\n| android框架层 | 面试的东西 binder context ams等  整理并理解 |\n| android应用层 |      架构 组件化 性能优化 各种常用框架      |\n|     java      |      oop基础  多线程  注解反射  虚拟机      |\n|    kotlin     |              语法糖 协程  函数              |\n|   设计模式    |                  源码常见                   |\n\n\n#### 第二期目标:\n|  name   |                      remark                       |\n| :-----: | :-----------------------------------------------: |\n| flutter |                  UI  调用原生sdk                  |\n|   c++   | 基础  cmake  11新特征  template  指针  内存  函数 |\n|  算法   |             leetcode-用c++去A 经典题              |\n\n\n#### 第三期目标:\n|     name     |         remark          |\n| :----------: | :---------------------: |\n| 安卓源码烧录 |   源码下载 编译 烧录    |\n|    音视频    | 入门  资源整合 编译使用 |\n\n\n#### 第四期目标:\n|         name         |             remark             |\n| :------------------: | :----------------------------: |\n|        物联网        |     智能家居 仿造  DIY自用     |\n| 常见AI模型和实际应用 | 目前已知算法实现  常见经典模型 |\n\n\n#### 第五期目标:\n| name |                        remark                        |\n| :--: | :--------------------------------------------------: |\n| 金融 | 基础  股票期货期权  贵金属  虚拟货币  交易  宏观周评 |\n| 生活 |                   做菜  健身 享受                    |\n\n","slug":"system","published":1,"date":"2021-11-07T16:37:09.197Z","updated":"2021-11-07T17:27:18.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvpigpg40000b8pu8aunangw","content":"<h3 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h3><p>从事安卓这几年，搭建体系这个事很久就有了，可惜前期自己太懒，中期耗费了很多时间去搞其他事情。后来想了想，得回归正轨，先把技术做到专家级别，然后再去往其他方面拓展，再给我一年时间。 </p>\n<h3 id=\"体系总览\"><a href=\"#体系总览\" class=\"headerlink\" title=\"体系总览\"></a>体系总览</h3><h6 id=\"android框架层\"><a href=\"#android框架层\" class=\"headerlink\" title=\"android框架层\"></a>android框架层</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ASOP基础</td>\n<td align=\"center\">12篇</td>\n<td align=\"center\">基于android 11 完成度 40%</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"www.baidu.com\">Binder</a></td>\n<td align=\"center\">3篇</td>\n<td align=\"center\">基于android 11 完成度 20%</td>\n</tr>\n</tbody></table>\n<h6 id=\"android应用层\"><a href=\"#android应用层\" class=\"headerlink\" title=\"android应用层\"></a>android应用层</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"kotlin\"><a href=\"#kotlin\" class=\"headerlink\" title=\"kotlin\"></a>kotlin</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"c\"><a href=\"#c\" class=\"headerlink\" title=\"c++\"></a>c++</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"flutter\"><a href=\"#flutter\" class=\"headerlink\" title=\"flutter\"></a>flutter</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<hr>\n<h6 id=\"物联网\"><a href=\"#物联网\" class=\"headerlink\" title=\"物联网\"></a>物联网</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"音视频\"><a href=\"#音视频\" class=\"headerlink\" title=\"音视频\"></a>音视频</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"未来要做的事\"><a href=\"#未来要做的事\" class=\"headerlink\" title=\"未来要做的事\"></a>未来要做的事</h3><h4 id=\"第一期目标\"><a href=\"#第一期目标\" class=\"headerlink\" title=\"第一期目标:\"></a>第一期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">android框架层</td>\n<td align=\"center\">面试的东西 binder context ams等  整理并理解</td>\n</tr>\n<tr>\n<td align=\"center\">android应用层</td>\n<td align=\"center\">架构 组件化 性能优化 各种常用框架</td>\n</tr>\n<tr>\n<td align=\"center\">java</td>\n<td align=\"center\">oop基础  多线程  注解反射  虚拟机</td>\n</tr>\n<tr>\n<td align=\"center\">kotlin</td>\n<td align=\"center\">语法糖 协程  函数</td>\n</tr>\n<tr>\n<td align=\"center\">设计模式</td>\n<td align=\"center\">源码常见</td>\n</tr>\n</tbody></table>\n<h4 id=\"第二期目标\"><a href=\"#第二期目标\" class=\"headerlink\" title=\"第二期目标:\"></a>第二期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">flutter</td>\n<td align=\"center\">UI  调用原生sdk</td>\n</tr>\n<tr>\n<td align=\"center\">c++</td>\n<td align=\"center\">基础  cmake  11新特征  template  指针  内存  函数</td>\n</tr>\n<tr>\n<td align=\"center\">算法</td>\n<td align=\"center\">leetcode-用c++去A 经典题</td>\n</tr>\n</tbody></table>\n<h4 id=\"第三期目标\"><a href=\"#第三期目标\" class=\"headerlink\" title=\"第三期目标:\"></a>第三期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">安卓源码烧录</td>\n<td align=\"center\">源码下载 编译 烧录</td>\n</tr>\n<tr>\n<td align=\"center\">音视频</td>\n<td align=\"center\">入门  资源整合 编译使用</td>\n</tr>\n</tbody></table>\n<h4 id=\"第四期目标\"><a href=\"#第四期目标\" class=\"headerlink\" title=\"第四期目标:\"></a>第四期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">物联网</td>\n<td align=\"center\">智能家居 仿造  DIY自用</td>\n</tr>\n<tr>\n<td align=\"center\">常见AI模型和实际应用</td>\n<td align=\"center\">目前已知算法实现  常见经典模型</td>\n</tr>\n</tbody></table>\n<h4 id=\"第五期目标\"><a href=\"#第五期目标\" class=\"headerlink\" title=\"第五期目标:\"></a>第五期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">金融</td>\n<td align=\"center\">基础  股票期货期权  贵金属  虚拟货币  交易  宏观周评</td>\n</tr>\n<tr>\n<td align=\"center\">生活</td>\n<td align=\"center\">做菜  健身 享受</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<h3 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h3><p>从事安卓这几年，搭建体系这个事很久就有了，可惜前期自己太懒，中期耗费了很多时间去搞其他事情。后来想了想，得回归正轨，先把技术做到专家级别，然后再去往其他方面拓展，再给我一年时间。 </p>\n<h3 id=\"体系总览\"><a href=\"#体系总览\" class=\"headerlink\" title=\"体系总览\"></a>体系总览</h3><h6 id=\"android框架层\"><a href=\"#android框架层\" class=\"headerlink\" title=\"android框架层\"></a>android框架层</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ASOP基础</td>\n<td align=\"center\">12篇</td>\n<td align=\"center\">基于android 11 完成度 40%</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"www.baidu.com\">Binder</a></td>\n<td align=\"center\">3篇</td>\n<td align=\"center\">基于android 11 完成度 20%</td>\n</tr>\n</tbody></table>\n<h6 id=\"android应用层\"><a href=\"#android应用层\" class=\"headerlink\" title=\"android应用层\"></a>android应用层</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"kotlin\"><a href=\"#kotlin\" class=\"headerlink\" title=\"kotlin\"></a>kotlin</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"c\"><a href=\"#c\" class=\"headerlink\" title=\"c++\"></a>c++</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"flutter\"><a href=\"#flutter\" class=\"headerlink\" title=\"flutter\"></a>flutter</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<hr>\n<h6 id=\"物联网\"><a href=\"#物联网\" class=\"headerlink\" title=\"物联网\"></a>物联网</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h6 id=\"音视频\"><a href=\"#音视频\" class=\"headerlink\" title=\"音视频\"></a>音视频</h6><table>\n<thead>\n<tr>\n<th align=\"center\">文章系列</th>\n<th align=\"center\">文章数目</th>\n<th align=\"center\">状态与备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"未来要做的事\"><a href=\"#未来要做的事\" class=\"headerlink\" title=\"未来要做的事\"></a>未来要做的事</h3><h4 id=\"第一期目标\"><a href=\"#第一期目标\" class=\"headerlink\" title=\"第一期目标:\"></a>第一期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">android框架层</td>\n<td align=\"center\">面试的东西 binder context ams等  整理并理解</td>\n</tr>\n<tr>\n<td align=\"center\">android应用层</td>\n<td align=\"center\">架构 组件化 性能优化 各种常用框架</td>\n</tr>\n<tr>\n<td align=\"center\">java</td>\n<td align=\"center\">oop基础  多线程  注解反射  虚拟机</td>\n</tr>\n<tr>\n<td align=\"center\">kotlin</td>\n<td align=\"center\">语法糖 协程  函数</td>\n</tr>\n<tr>\n<td align=\"center\">设计模式</td>\n<td align=\"center\">源码常见</td>\n</tr>\n</tbody></table>\n<h4 id=\"第二期目标\"><a href=\"#第二期目标\" class=\"headerlink\" title=\"第二期目标:\"></a>第二期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">flutter</td>\n<td align=\"center\">UI  调用原生sdk</td>\n</tr>\n<tr>\n<td align=\"center\">c++</td>\n<td align=\"center\">基础  cmake  11新特征  template  指针  内存  函数</td>\n</tr>\n<tr>\n<td align=\"center\">算法</td>\n<td align=\"center\">leetcode-用c++去A 经典题</td>\n</tr>\n</tbody></table>\n<h4 id=\"第三期目标\"><a href=\"#第三期目标\" class=\"headerlink\" title=\"第三期目标:\"></a>第三期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">安卓源码烧录</td>\n<td align=\"center\">源码下载 编译 烧录</td>\n</tr>\n<tr>\n<td align=\"center\">音视频</td>\n<td align=\"center\">入门  资源整合 编译使用</td>\n</tr>\n</tbody></table>\n<h4 id=\"第四期目标\"><a href=\"#第四期目标\" class=\"headerlink\" title=\"第四期目标:\"></a>第四期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">物联网</td>\n<td align=\"center\">智能家居 仿造  DIY自用</td>\n</tr>\n<tr>\n<td align=\"center\">常见AI模型和实际应用</td>\n<td align=\"center\">目前已知算法实现  常见经典模型</td>\n</tr>\n</tbody></table>\n<h4 id=\"第五期目标\"><a href=\"#第五期目标\" class=\"headerlink\" title=\"第五期目标:\"></a>第五期目标:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">remark</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">金融</td>\n<td align=\"center\">基础  股票期货期权  贵金属  虚拟货币  交易  宏观周评</td>\n</tr>\n<tr>\n<td align=\"center\">生活</td>\n<td align=\"center\">做菜  健身 享受</td>\n</tr>\n</tbody></table>\n"},{"title":"c++基础","date":"2021-11-08T17:15:37.000Z","_content":"\n##### 编译流程\ntxt -> compiling + linking -> exe\n\ncompiling  \n* c++编译器把文本变成终极格式 -obj     \n* pre-process  评估preprocessor语句\n* tokenizing 标记解释\n* parsing\t解析  抽象语法树  -  解释成编译器能懂和处理的语言\t\t\t\t          \n* 编译器把代码转化成const data 或  instructions \n* include   -  只是把 .h文件里面的代码copy过来  例如 xx.h只有个 } 然后在main最后一行 用 #include \"xx.h\" 把}补进来\n* #define INTEGER int -  在main可以  INTEGER main(){}  只是替换 \n* #if 0 main{}  #endif  根据特定条件包含或剔除代码  就不会执行了\n* obj文件里面是二进制  cpu的机器码  可以转为asm可读-汇编指令\n* #progma once 只 include一次  和老的写法 { #ifndef  #define  #endif } 一样\n* c标准库头文件一般有.h扩展文件  而c++没得\n\nlinker 把cpp编译好的obj串成exe可执行文件 \n* 找到每个符号和函数的位置 链接在一起\n* link error code和compiler error code都不一样的  容易区分\n* 如果找不到一模一样的 就会报错  相同的名字和签名-返回值和参数相同\n* static的函数 被include 只会在内部有效 \n* inline的函数 把函数的身体拿过来调用 和copy类似 \n\nstatic linking  &  dynamic libraries \nstatic发生在编译期间  dynamic发生在runtime  \t lib是编译时用到的，dll是运行时用到的\n\nPrecompiled Headers   预编译 头文件 改动东西时  编译会很快 尤其时大型项目  二进制  本质是包含一堆其他头文件的头文件 \n\t\t\t\t\t  针对那些不经常改变的东西  用预编译 头文件 \n\n* * *\n##### 数据类型\n内存  堆栈\nchar 1byte \nshort 2byte \nint 4byte \nlong 4byte\nlong long 8byte\nfloat  4byte   5.5f\ndouble 8byte\t5.5\nbool   1byte   无法创建1bit的变量类型 内存没法寻址  1byte=8bit\n数据类型多大根据编译器来的 用sizeof操作符来检查下  返回byte个数 \n为了不搞多个函数 用inline 不用跳内存 push堆栈之类的  嵌套越多 就越慢\n```c++\nCasting\t\ttype casting 类型转换   隐式转换  例如  int a = (int) 1.34f;   \n\t\t\t\t\t\t\t\t\t静态转换  stataic_cast<int>(value)  \n\t\t\t\t\t\t\t\t\t动态转换  dynamic_cast<Derived*>(base)\n动态转换  dynamic_cast 如果有效 则返回指针值 否则null   \n\t\tRTTI 运行时类型信息 让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型\n\t\t可以设置编译器  把这个关掉  再去编译 会得到warning信息  \n\nstrings faster  性能  处理字符串更快\t\tvoid printName(const std::string& name)\n\t\t\t\tstring视图 对现有内存 开启一个小窗口  没新对象产生   \n\t\t\t\t\tstd::string name = \"yan chernikov\"; \n\t\t\t\t\tstd::string_view firstname(name.c_str(), 3);\n\t\t\t\t\tstd::string_view lastname(name.c_str()+4, 3);\n```\nstd::string 会自动扩容  初始化是8个字节  \n```c++\nDATA STRUCTURES \t   arrays,lists,sets,maps,trees\n\t\t\t\tint array[5];   int* heapArray = new int[5];    std::array<int,5> arrays;  class Array{  int* m_Data;  m_Data=(int*)alloca(size); }\n                \nITERATORS     for(int i=0; i<arr.size(); i++)    for(int item : arr)     for(std::vector<int>::iterator it=arr.begin(); it!=arr.end(); it++)\n\t\t\t  include <unordered_map>\t->   std::unordered_map<std::string, int> map; \n\n自己写一个vector类  不复制 直接 move push  pop  clear  delete  \n\n\n```\n\n* * *\n##### 指针\n计算机操作的本质是对内存的操作  访问内存可以是地址，起名字或者起小名\nreference别名 int a=5; int &ref =a; 那么ref就是a的别名\nvoid plus(int& a) 不会传参而是传内存地址   比指针要好看和简洁些\n\nraw pointer   原始指针   smart pointer 智能指针\n一个指针只是地址  整数 存储内存地址  \nchar* buffer = new char[8]\nchar** ptr = &buffer\n那么 ptr是内存地址  指向buffer的内存地址  然后通过指向buffer的内存地址找到buffer\naddress ->  address -> value\n\n```c++\n智能指针\tstd::unique_ptr, std::shared_ptr, std::weak_ptr\n\t\t自动申请和释放内存  不要new和delete   超出scope就释放\n\t\t#include <memory> \n\t\tstd::unique_ptr<Eneity> eneity(new Eneity());  唯一指针 在scope后就会自动销毁\n\t\tstd::shared_ptr<Eneity> eneity = std::make_shared<Eneity>(); // 引用计数  没用引用就释放  可以复制 共同指向\n\t\tstd::weak_ptr<Eneity> e0;   e0 = entity;  如果离开了entity的scope  e0也会释放  弱引用        \n```\n\n```c++\nlambdas\t 和函数指针搭配食用    https://en.cppreference.com/w/cpp/language/lambda\n\t\t  auto lambda = [](int value) {std::cout<<\"value\"<<value<<std::endl; };\n\t\t  forEach(values, lambda);\n\t\t  \n\t\t  使用lambda之外的值  四种方式 =  &  a  &a  \n\t\t  void forEach(const std::vector<int>& values, const std::function<void(int)>& func){}\n\t\t  int a = 5;\n\t\t  auto lambda = [=](int value) mutable {a=5; std::cout<<\"value\"<<a<<std::endl;};\n\t\t  forEach(values, lambda)\n\t\t  \n\t\t  类似于rxjava里面的filter\n\t\t  auto it = std::find_if(values.begin(), values.end(), [](int value){return value>3;});\n\t\t  \n\t\t \nfuntion pointer  函数指针    和python一样  高阶函数  把函数当作参数变量\n\t\t定义函数  void HelloWorld(int a) { //打印逻辑 }\n\t\t\t\t\n\t\t使用指针 typedef void(*hellofunction)(int);\n\t\t\t\t HelloFunction fu = HelloWorld;\n\t\t\t\t fu(8);\n\t\t定义高阶函数  void forEach(const std::vector<int>& values, void(*func)(int))\n\t\t\t\t\t  {  for (int item : values)  func(item); }\n\t\t使用 \t\tstd::vector<int> values = {1,2,3,4,5,6} \n\t\t\t\t\tforEach(values, HelloWorld)\n\t\t\t\t\t或者内部函数写法  forEach(values, [](int value){ std::cout<<\"value\"<<std::endl; })\n                    \nUnion  类似于别名    在Vector4，去改变x就相当于改变a \nVector2{\n\tfloat x,y;\n};\nstruct Vector4\n{\n\tunion{\n\t\tstruct{\n\t\t\tfloat x,y,z,w;\n\t\t};\n\t\tstruct{\n\t\t\tVector2 a,b;\n\t\t};\n\t}\n}\n```\n\n* * *\n\n##### OOP\nOOP   面向对象  --  面向过程，基于对象，面向对象，泛型编程\nextern  在外部寻找 \nstatic 只执行初始化一次 只会在你声明的那个c++文件是可见的  extern 外部声明也不可以 \n\n构造函数 析构函数  Eneity() +   ~Eneity() =>  Eneity e;  \n继承: : public Eneity  \nvirtual fun虚函数:  允许覆盖子类中的方法   如果要想实现多态 父类必须是虚函数 子类才能覆盖\n 俩个时间损耗 \n1.需要额外的内存将信息存储在虚函数表中\n 2.每次调用需要遍历虚函数表 查看映射的函数 \n现在允许加个 override  std::getName() override {return m_name; }\n\npure virtual fun 纯虚函数   像java的interface   virtuan std::string getName() = 0; \n\n```c++\nImplicit Conversion  隐式转换   explicit 关键字  构造函数 \n\t隐式转换  构造函数 Entity(const std::string& name)\n\t\t\t\t\t\t\t: m_name(name), m_age(-1) {}\n\t\t\t\t\t   Entity(int age)\n\t\t\t\t\t\t\t: m_name(\"unknow\"), m_age(age) {}\n\t调用的时候  直接      Entity a = \"CHERNO\"; 或者  Entity b = 22;\n\t这会去调用构造函数 和 Entity a = Entity(\"CHERNO\"); 或者  Entity b = Entity(22); 一样的效果\n\texplicit 关键字 就是为了禁止这种奇奇怪怪的东西出现  例\n\t\t\texplicit Entity(const std::string& name)\n\t\t\t\t\t\t : m_name(name), m_age(-1) {}\n\t\t\t那么 就不能像上面那样玩了   必须 Entity(\"cherno\"); 去实例化对象  \n\ninitializer list：  性能优化 不会创建新的对象 直接赋值 在构造函数中使用  按顺序来 \n\t\t\t\t\t Entity()\n\t\t\t\t\t\t  : m_name(\"Unknow\"), m_score(0)\n\t\t\t\t\t {}\n                     \n对象生命周期 \n\t int main(){\n\t\t{\n\t\t\tEneity e; //执行构造函数\t\t\t\t\t如果  Entity* e=new Entity(); \n\t\t}    \t\t  //执行析构函数  free memory\t\t// 不会释放 在堆上面创建的实例\n\t\treturn 0;\n\t }\n\nthis\t当前对象实例的指针\n\n箭头  Entity e; e.print();  but  Entity* ptr = &e; ptr->print();\n\t  操作符重载  更酷的代码    \n       \nVirtual Destructors\t 虚析构函数\t  父类base 子类derived  \n\t\t\t\t\t 如果创建base    父类构造函数 -> 父类析构函数\n\t\t\t\t\t 如果创建derived 父类构造函数  子类构造函数 ->  子类析构函数 父类析构函数\n\t\t\t\t\t 如果用多态 \t 父类构造函数  子类构造函数 ->  父类析构函数  \t\t======= 不会去执行子类析构函数 内存泄漏maybe\n\t\t\t\t\t\t\t\t\t 在父类析构函数前面加上  virtual 关键字  意味着有可能被扩展  需要调用扩展者的析构函数 \n                                     \nsingletones    在C++中只是将一堆全局变量和静态函数组织起来的方法   牛逼 比java灵活\n\t\t\t\tSingleton(const Singleton&) = delete; 删除掉默认的构造函数                                 \n```\n* * *\n##### 函数\n```c++\n函数多个返回值  \ttuple  \t\t pair   \n\t\t\t#include <itility>  #include <functional>  函数返回类型=std::tuple<std::string, std::string>   return std::make_pair(s1,s2);\n\t\t\t或者 struct  作为函数 返回多个值  \n\t\t\t或者对象  也可以 \n            \nSTRUCTURED BINDINGS  结构化绑定声明  在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。\n\t\t\t\t\t 用tuple  返回多个值 \n```\n* * *\n##### 数组和字符串\n```c++\nstring：  传统的char需要以0结尾  才能打印  char name[5] = {'n', 'a', 'm', 'e', 0}; \n\t\t  用string库   std::string name = \"name\";\n\t\t  用stdlib.h   char=u8\"\"  wchar_t=L\"\"  char16_t=u\"\"  char32_t=U\"\"    std::u32string   R\"\"  \n\t\t  字符串拼接 \"cherno\"s + \"hello\"  或者  std::string(\"cherno\") + \"hello\" \n          \narray:  创建数组\n\t\t\tint arr1[5];     \n\t\t\tint* arr2 = new int[5];   delete[] arr2;\n\t\t\tstd::array<int,5> arr3;    #include <array>\n            \n动态数组 std::vector  不指定大小  会自动扩容  在堆上 \n\t\t#include <vector>  std::vector<Entity> arrs;\n\t\tarrs.push_back    for(Entity item : arrs) {}   arrs.erase(2)\t\t\n\t\tarrs.emplace_back() 不要复制 \n        \nsorting\t\tstd::sort  \n\t\t\tstd::vector<int> values = {3, 5, 1, 4, 2};\n\t\t\tstd::sort(values.begin(), values.end());\n\t\t\tstd::sort(values.begin(), values.end(), [](int a, int b) {\n\t\t\t\treturn a > b;\n\t\t\t});\n\nMultidimensional Arrays  多维数组 \n\t\t\t考虑内存优化  分配一块紧凑的  设置宽度去赋值  会很快  \n            \n```\n\n* * *\n##### 操作内存\n\n```c++\n创建对象  在栈和堆的区别  \n\t\t在堆上面   Entity* entity = new Eneity(\"Cherno\"); 必须释放 delete entity;\n\t\t在栈  Entity e; 默认调用了构造函数  在函数中  生命周期就是函数执行完成的时候\n        \nnew   在堆上面分配内存  要手动释放\t\n\tEntity* e = new Eneity();    调用了构造函数\n\tEntity* e = (Entity*)malloc(siizeof(Entity));  只是存粹的分配内存\n\ncopy 复制  c++里面的复制和java相反  int a=2; int b=a; 其实b会copy到a  改变b 不会影响a\n\t  用指针的话 就不一样  在堆  指向的是内存  \n\t  memcpy() 复制字符串 \n\t  在对象里面  用运算符重载  真的好看  例如  char& operator[](unsigned int index){ return m_buffer[index]; }\n\t  真正的深拷贝  靠构造函数来  重新在堆上分配内存  复制 memcpy\n\t  函数传递引用  不能改变值  void print(const String& string) \n```\n```c++\nMove Semantics\t\t移动语义\t当一个函数的参数按值传递时，这就会进行拷贝 \n\t\t\t\t\tstd::move、std::forward  避免copy的一种手段    避免内存的重新分配\n\t\t\t\t\t右值引用提供了一个暂时的对象 我们可以进行移动  右值引用和移动语义允许我们避免不必要的拷贝\n\t\t\t\t\t要移动而不是拷贝右值参数的内容。这就会节省很多的空间\n\t\t\t\t\t\t\t\tint a =10;\n\t\t\t\t\t\t\t\tint&  lr = a;       // a 是个变量\n\t\t\t\t\t\t\t\tint&& rv = 10;      // 10 是常量\t\n\t\t\t\t\tString string = \"hello\";\n\t\t\t\t\tString dest((String&&)string);   //move string to dest  no copy \n\t\t\t\t\tString dest( std::move(string)); //move string to dest  no copy \n\t\t\t\t\tString dest = std::move(string); //move string to dest  no copy \n```\n* * *\n##### 关键字\n```c++\nmutable:  俩种用途   一种是 const  另一种是 lambda    英文  sth changeable\n\t\t  用const修饰的函数 不能改东西  但想改  就用mutable去修饰需要改变的变量\n\tint x = 8;\n    auto f = [=]() mutable   // [& =]  ->  {&传递地址}  {=复制值不改变原来的值}\n    {\n        x++;\n        std::cout<< x << std::endl;\n    };\n    //x = 8  just copy not reference passing  只是复制 会重新new一个 没传递地址 不会改变原值\n\nconst： 修饰变量  全局定义 或者函数传参  sth不变   const int MAX_AGE = 120;  \n\t\t修饰函数 放在后面 里面的东西不能改变  但是可以靠mutable来改变\nclase Entity{\nprivate:\n\tint m_x, m_y;\n\tmutable int var;\npublic:\n\t\tint getX() const {\n\t\t  var =2;   //这里其实不允许改变的  可以用mutable去修饰var \n\t\t  return m_x; \n\t    }\n}\n\n内存自己操作  操作符operator自定义  灵活\n\n运算符重载    bool operator==const(Vector2& other) const    俩个类相等\n\t\t\t\t{\n\t\t\t\t\treturn x==other.x && y=other.y;\n\t\t\t\t}\n\t使用:  Vector2 result1; Vector2 result2;  if(result1==result2) { } \n    \n\nTrack MEMORY ALLOCATIONS  就是重载关键字  然后把里面的东西弄出来  强的一批  和java反射一样 \n\t\tvoid* operator new(size_t size)\n\t\t{\n\t\t\tstd::cout<<\"allocating \"<<size<<\" bytes\\n\";\n\t\t\treturn malloc(size);\n\t\t}\n\n\t\tvoid operator delete(void* memory, size_t size)\n\t\t{\n\t\t\tstd::cout<<\"freeing \"<<size<<\" bytes\\n\";\n\t\t\tfree(memory);\n\t\t}\n        \n\nauto   自动推导类型  如果是string int 基础 不要用  复杂的 写起来很长的就用 代码非常简洁  例如array迭代器 \n\t\tstd::vector<std::string>::iterator it = strings::begin();    =>  auto it = strings.begin();\n\n\nMacros  宏定义 define  替换字符串   就是替换    用 \\ 换行\n\t\t#define LOG(x) std::cout<<x<<std::endl   LOG(\"HELLO\");\n\t\t还能用#if  #else #endif 去做条件适配\n\n \ntemplate   就是泛型  \tArray<std::string, 5> array;  Array<int, 5> array;\n\n\t\t\t\t\t\ttemplate<typename T, int N>\n\t\t\t\t\t\tclass Array\n\t\t\t\t\t\t{\n\t\t\t\t\t\tprivate:\n\t\t\t\t\t\t\tT m_array[N];\n\t\t\t\t\t\tpublic:\n\t\t\t\t\t\t\tint get_size() const {return N;}\n\t\t\t\t\t\t};\n                        \nTiming\t\t#include <cherno>    std::chrono::high_resolution_clock::now()\n\t\t\t统计函数执行时间  用struct放start和end  构造函数初始化start 在析构函数初始化end 打印耗时 \n\t\t\t\t\t\t\t  在需要统计的函数 创建Timer  因为是栈 所以脱离scope就会释放 妙啊 这个设计 \n\n\nThread  线程 \t#include <thread>\tstd::thread worker(hello);  worker.join(); \n\t\t\t\tvoid hello(){ while(true){ std::cout<<\"hello\"<<std::endl;} }             \n```\n* * *\n##### 新特征\n```c++\n#include <optional>  c++17新特征   \n\t\t\t\t\tstd::optional<std::string> ReadFile(const std::string& filepath)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::ifstream stream(filepath);\n\t\t\t\t\t\tif(stream)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string result;\n\t\t\t\t\t\t\t//read fil\n\t\t\t\t\t\t\tstream.close();\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\t使用:\n\t\t\t\t\tstd::optional<std::string> data = ReadFile(\"\");\n\t\t\t\t\tif(data.has_value()){  }    就能知道文件是否存在 或者打开过 \n                    \nMultiple TYPES of Data in a SINGLE VARIABLE  一个变量保存多个类型数据  c++17新特征 \n\t\t\t\t\t#include <variant>   std::variant<std::string, int> data;\n\t\t\t\t\t\t\t\t\t\t data = \"cherno\"; data=2;\n\t\t\t\t\t\t\t\t\t\t std::get<std::string>(data)   or std::get<int>(data)                    \nstore ANY data     存储任何数据   #include <any>   std::any   c++17新特征 \n\n\n\n```\n* * *\n##### 其他\nusing namespace   最好不用  难调试  特别是大型的项目 \nType Punning\t类型双关\tint a=50;  double value = *(double*)&a;  奇怪的用法  最好别碰 \n断点 有条件的断点  \nBENCHMARKING 工具  测试性能  用之前 类去做  构造函数开始  析构函数结束  用scope {}\ngoogle chrome  tracing  https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\n\n```c++\nstd::asyn\t\t并发  多线程  #include <future>   std::async( std::launch::async, loadmesh(meshes,filepath); )\n\t\t\t\t锁  std::mutex  s_mutex;    std::lock_guard<std::mutex> lock(s_mutex);  \n```\nlvalues and rvalues\t  int i=10;  i=lvalue  10=rvalue   i可以改  10不能改 \nArgument Evaluation Order  参数传递顺序 \t\n\nStatic Analysis   code review 分析哪里写的有问题    用工具  VS自带的也有 \n\n持续集成（Continuous Integration）\tJenkins\t  不管是哪一个持续集成工具，它本质上只不过是一个定时器，时间一到，做你脚本里让它去做的事\n\n看别人的开源代码  然后吸收营养  直到自己也能写出那样骚的代码   用静态分析工具  找到哪些不合理的地方  然后改进\n\n[youtube](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)\n\n[参考手册](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n\n[编译器](https://wandbox.org/)\n\n[书籍](https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th)","source":"_posts/c++_basic.md","raw":"---\ntitle: c++基础\ndate: 2021-11-09 01:15:37\ntags: c++\n---\n\n##### 编译流程\ntxt -> compiling + linking -> exe\n\ncompiling  \n* c++编译器把文本变成终极格式 -obj     \n* pre-process  评估preprocessor语句\n* tokenizing 标记解释\n* parsing\t解析  抽象语法树  -  解释成编译器能懂和处理的语言\t\t\t\t          \n* 编译器把代码转化成const data 或  instructions \n* include   -  只是把 .h文件里面的代码copy过来  例如 xx.h只有个 } 然后在main最后一行 用 #include \"xx.h\" 把}补进来\n* #define INTEGER int -  在main可以  INTEGER main(){}  只是替换 \n* #if 0 main{}  #endif  根据特定条件包含或剔除代码  就不会执行了\n* obj文件里面是二进制  cpu的机器码  可以转为asm可读-汇编指令\n* #progma once 只 include一次  和老的写法 { #ifndef  #define  #endif } 一样\n* c标准库头文件一般有.h扩展文件  而c++没得\n\nlinker 把cpp编译好的obj串成exe可执行文件 \n* 找到每个符号和函数的位置 链接在一起\n* link error code和compiler error code都不一样的  容易区分\n* 如果找不到一模一样的 就会报错  相同的名字和签名-返回值和参数相同\n* static的函数 被include 只会在内部有效 \n* inline的函数 把函数的身体拿过来调用 和copy类似 \n\nstatic linking  &  dynamic libraries \nstatic发生在编译期间  dynamic发生在runtime  \t lib是编译时用到的，dll是运行时用到的\n\nPrecompiled Headers   预编译 头文件 改动东西时  编译会很快 尤其时大型项目  二进制  本质是包含一堆其他头文件的头文件 \n\t\t\t\t\t  针对那些不经常改变的东西  用预编译 头文件 \n\n* * *\n##### 数据类型\n内存  堆栈\nchar 1byte \nshort 2byte \nint 4byte \nlong 4byte\nlong long 8byte\nfloat  4byte   5.5f\ndouble 8byte\t5.5\nbool   1byte   无法创建1bit的变量类型 内存没法寻址  1byte=8bit\n数据类型多大根据编译器来的 用sizeof操作符来检查下  返回byte个数 \n为了不搞多个函数 用inline 不用跳内存 push堆栈之类的  嵌套越多 就越慢\n```c++\nCasting\t\ttype casting 类型转换   隐式转换  例如  int a = (int) 1.34f;   \n\t\t\t\t\t\t\t\t\t静态转换  stataic_cast<int>(value)  \n\t\t\t\t\t\t\t\t\t动态转换  dynamic_cast<Derived*>(base)\n动态转换  dynamic_cast 如果有效 则返回指针值 否则null   \n\t\tRTTI 运行时类型信息 让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型\n\t\t可以设置编译器  把这个关掉  再去编译 会得到warning信息  \n\nstrings faster  性能  处理字符串更快\t\tvoid printName(const std::string& name)\n\t\t\t\tstring视图 对现有内存 开启一个小窗口  没新对象产生   \n\t\t\t\t\tstd::string name = \"yan chernikov\"; \n\t\t\t\t\tstd::string_view firstname(name.c_str(), 3);\n\t\t\t\t\tstd::string_view lastname(name.c_str()+4, 3);\n```\nstd::string 会自动扩容  初始化是8个字节  \n```c++\nDATA STRUCTURES \t   arrays,lists,sets,maps,trees\n\t\t\t\tint array[5];   int* heapArray = new int[5];    std::array<int,5> arrays;  class Array{  int* m_Data;  m_Data=(int*)alloca(size); }\n                \nITERATORS     for(int i=0; i<arr.size(); i++)    for(int item : arr)     for(std::vector<int>::iterator it=arr.begin(); it!=arr.end(); it++)\n\t\t\t  include <unordered_map>\t->   std::unordered_map<std::string, int> map; \n\n自己写一个vector类  不复制 直接 move push  pop  clear  delete  \n\n\n```\n\n* * *\n##### 指针\n计算机操作的本质是对内存的操作  访问内存可以是地址，起名字或者起小名\nreference别名 int a=5; int &ref =a; 那么ref就是a的别名\nvoid plus(int& a) 不会传参而是传内存地址   比指针要好看和简洁些\n\nraw pointer   原始指针   smart pointer 智能指针\n一个指针只是地址  整数 存储内存地址  \nchar* buffer = new char[8]\nchar** ptr = &buffer\n那么 ptr是内存地址  指向buffer的内存地址  然后通过指向buffer的内存地址找到buffer\naddress ->  address -> value\n\n```c++\n智能指针\tstd::unique_ptr, std::shared_ptr, std::weak_ptr\n\t\t自动申请和释放内存  不要new和delete   超出scope就释放\n\t\t#include <memory> \n\t\tstd::unique_ptr<Eneity> eneity(new Eneity());  唯一指针 在scope后就会自动销毁\n\t\tstd::shared_ptr<Eneity> eneity = std::make_shared<Eneity>(); // 引用计数  没用引用就释放  可以复制 共同指向\n\t\tstd::weak_ptr<Eneity> e0;   e0 = entity;  如果离开了entity的scope  e0也会释放  弱引用        \n```\n\n```c++\nlambdas\t 和函数指针搭配食用    https://en.cppreference.com/w/cpp/language/lambda\n\t\t  auto lambda = [](int value) {std::cout<<\"value\"<<value<<std::endl; };\n\t\t  forEach(values, lambda);\n\t\t  \n\t\t  使用lambda之外的值  四种方式 =  &  a  &a  \n\t\t  void forEach(const std::vector<int>& values, const std::function<void(int)>& func){}\n\t\t  int a = 5;\n\t\t  auto lambda = [=](int value) mutable {a=5; std::cout<<\"value\"<<a<<std::endl;};\n\t\t  forEach(values, lambda)\n\t\t  \n\t\t  类似于rxjava里面的filter\n\t\t  auto it = std::find_if(values.begin(), values.end(), [](int value){return value>3;});\n\t\t  \n\t\t \nfuntion pointer  函数指针    和python一样  高阶函数  把函数当作参数变量\n\t\t定义函数  void HelloWorld(int a) { //打印逻辑 }\n\t\t\t\t\n\t\t使用指针 typedef void(*hellofunction)(int);\n\t\t\t\t HelloFunction fu = HelloWorld;\n\t\t\t\t fu(8);\n\t\t定义高阶函数  void forEach(const std::vector<int>& values, void(*func)(int))\n\t\t\t\t\t  {  for (int item : values)  func(item); }\n\t\t使用 \t\tstd::vector<int> values = {1,2,3,4,5,6} \n\t\t\t\t\tforEach(values, HelloWorld)\n\t\t\t\t\t或者内部函数写法  forEach(values, [](int value){ std::cout<<\"value\"<<std::endl; })\n                    \nUnion  类似于别名    在Vector4，去改变x就相当于改变a \nVector2{\n\tfloat x,y;\n};\nstruct Vector4\n{\n\tunion{\n\t\tstruct{\n\t\t\tfloat x,y,z,w;\n\t\t};\n\t\tstruct{\n\t\t\tVector2 a,b;\n\t\t};\n\t}\n}\n```\n\n* * *\n\n##### OOP\nOOP   面向对象  --  面向过程，基于对象，面向对象，泛型编程\nextern  在外部寻找 \nstatic 只执行初始化一次 只会在你声明的那个c++文件是可见的  extern 外部声明也不可以 \n\n构造函数 析构函数  Eneity() +   ~Eneity() =>  Eneity e;  \n继承: : public Eneity  \nvirtual fun虚函数:  允许覆盖子类中的方法   如果要想实现多态 父类必须是虚函数 子类才能覆盖\n 俩个时间损耗 \n1.需要额外的内存将信息存储在虚函数表中\n 2.每次调用需要遍历虚函数表 查看映射的函数 \n现在允许加个 override  std::getName() override {return m_name; }\n\npure virtual fun 纯虚函数   像java的interface   virtuan std::string getName() = 0; \n\n```c++\nImplicit Conversion  隐式转换   explicit 关键字  构造函数 \n\t隐式转换  构造函数 Entity(const std::string& name)\n\t\t\t\t\t\t\t: m_name(name), m_age(-1) {}\n\t\t\t\t\t   Entity(int age)\n\t\t\t\t\t\t\t: m_name(\"unknow\"), m_age(age) {}\n\t调用的时候  直接      Entity a = \"CHERNO\"; 或者  Entity b = 22;\n\t这会去调用构造函数 和 Entity a = Entity(\"CHERNO\"); 或者  Entity b = Entity(22); 一样的效果\n\texplicit 关键字 就是为了禁止这种奇奇怪怪的东西出现  例\n\t\t\texplicit Entity(const std::string& name)\n\t\t\t\t\t\t : m_name(name), m_age(-1) {}\n\t\t\t那么 就不能像上面那样玩了   必须 Entity(\"cherno\"); 去实例化对象  \n\ninitializer list：  性能优化 不会创建新的对象 直接赋值 在构造函数中使用  按顺序来 \n\t\t\t\t\t Entity()\n\t\t\t\t\t\t  : m_name(\"Unknow\"), m_score(0)\n\t\t\t\t\t {}\n                     \n对象生命周期 \n\t int main(){\n\t\t{\n\t\t\tEneity e; //执行构造函数\t\t\t\t\t如果  Entity* e=new Entity(); \n\t\t}    \t\t  //执行析构函数  free memory\t\t// 不会释放 在堆上面创建的实例\n\t\treturn 0;\n\t }\n\nthis\t当前对象实例的指针\n\n箭头  Entity e; e.print();  but  Entity* ptr = &e; ptr->print();\n\t  操作符重载  更酷的代码    \n       \nVirtual Destructors\t 虚析构函数\t  父类base 子类derived  \n\t\t\t\t\t 如果创建base    父类构造函数 -> 父类析构函数\n\t\t\t\t\t 如果创建derived 父类构造函数  子类构造函数 ->  子类析构函数 父类析构函数\n\t\t\t\t\t 如果用多态 \t 父类构造函数  子类构造函数 ->  父类析构函数  \t\t======= 不会去执行子类析构函数 内存泄漏maybe\n\t\t\t\t\t\t\t\t\t 在父类析构函数前面加上  virtual 关键字  意味着有可能被扩展  需要调用扩展者的析构函数 \n                                     \nsingletones    在C++中只是将一堆全局变量和静态函数组织起来的方法   牛逼 比java灵活\n\t\t\t\tSingleton(const Singleton&) = delete; 删除掉默认的构造函数                                 \n```\n* * *\n##### 函数\n```c++\n函数多个返回值  \ttuple  \t\t pair   \n\t\t\t#include <itility>  #include <functional>  函数返回类型=std::tuple<std::string, std::string>   return std::make_pair(s1,s2);\n\t\t\t或者 struct  作为函数 返回多个值  \n\t\t\t或者对象  也可以 \n            \nSTRUCTURED BINDINGS  结构化绑定声明  在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。\n\t\t\t\t\t 用tuple  返回多个值 \n```\n* * *\n##### 数组和字符串\n```c++\nstring：  传统的char需要以0结尾  才能打印  char name[5] = {'n', 'a', 'm', 'e', 0}; \n\t\t  用string库   std::string name = \"name\";\n\t\t  用stdlib.h   char=u8\"\"  wchar_t=L\"\"  char16_t=u\"\"  char32_t=U\"\"    std::u32string   R\"\"  \n\t\t  字符串拼接 \"cherno\"s + \"hello\"  或者  std::string(\"cherno\") + \"hello\" \n          \narray:  创建数组\n\t\t\tint arr1[5];     \n\t\t\tint* arr2 = new int[5];   delete[] arr2;\n\t\t\tstd::array<int,5> arr3;    #include <array>\n            \n动态数组 std::vector  不指定大小  会自动扩容  在堆上 \n\t\t#include <vector>  std::vector<Entity> arrs;\n\t\tarrs.push_back    for(Entity item : arrs) {}   arrs.erase(2)\t\t\n\t\tarrs.emplace_back() 不要复制 \n        \nsorting\t\tstd::sort  \n\t\t\tstd::vector<int> values = {3, 5, 1, 4, 2};\n\t\t\tstd::sort(values.begin(), values.end());\n\t\t\tstd::sort(values.begin(), values.end(), [](int a, int b) {\n\t\t\t\treturn a > b;\n\t\t\t});\n\nMultidimensional Arrays  多维数组 \n\t\t\t考虑内存优化  分配一块紧凑的  设置宽度去赋值  会很快  \n            \n```\n\n* * *\n##### 操作内存\n\n```c++\n创建对象  在栈和堆的区别  \n\t\t在堆上面   Entity* entity = new Eneity(\"Cherno\"); 必须释放 delete entity;\n\t\t在栈  Entity e; 默认调用了构造函数  在函数中  生命周期就是函数执行完成的时候\n        \nnew   在堆上面分配内存  要手动释放\t\n\tEntity* e = new Eneity();    调用了构造函数\n\tEntity* e = (Entity*)malloc(siizeof(Entity));  只是存粹的分配内存\n\ncopy 复制  c++里面的复制和java相反  int a=2; int b=a; 其实b会copy到a  改变b 不会影响a\n\t  用指针的话 就不一样  在堆  指向的是内存  \n\t  memcpy() 复制字符串 \n\t  在对象里面  用运算符重载  真的好看  例如  char& operator[](unsigned int index){ return m_buffer[index]; }\n\t  真正的深拷贝  靠构造函数来  重新在堆上分配内存  复制 memcpy\n\t  函数传递引用  不能改变值  void print(const String& string) \n```\n```c++\nMove Semantics\t\t移动语义\t当一个函数的参数按值传递时，这就会进行拷贝 \n\t\t\t\t\tstd::move、std::forward  避免copy的一种手段    避免内存的重新分配\n\t\t\t\t\t右值引用提供了一个暂时的对象 我们可以进行移动  右值引用和移动语义允许我们避免不必要的拷贝\n\t\t\t\t\t要移动而不是拷贝右值参数的内容。这就会节省很多的空间\n\t\t\t\t\t\t\t\tint a =10;\n\t\t\t\t\t\t\t\tint&  lr = a;       // a 是个变量\n\t\t\t\t\t\t\t\tint&& rv = 10;      // 10 是常量\t\n\t\t\t\t\tString string = \"hello\";\n\t\t\t\t\tString dest((String&&)string);   //move string to dest  no copy \n\t\t\t\t\tString dest( std::move(string)); //move string to dest  no copy \n\t\t\t\t\tString dest = std::move(string); //move string to dest  no copy \n```\n* * *\n##### 关键字\n```c++\nmutable:  俩种用途   一种是 const  另一种是 lambda    英文  sth changeable\n\t\t  用const修饰的函数 不能改东西  但想改  就用mutable去修饰需要改变的变量\n\tint x = 8;\n    auto f = [=]() mutable   // [& =]  ->  {&传递地址}  {=复制值不改变原来的值}\n    {\n        x++;\n        std::cout<< x << std::endl;\n    };\n    //x = 8  just copy not reference passing  只是复制 会重新new一个 没传递地址 不会改变原值\n\nconst： 修饰变量  全局定义 或者函数传参  sth不变   const int MAX_AGE = 120;  \n\t\t修饰函数 放在后面 里面的东西不能改变  但是可以靠mutable来改变\nclase Entity{\nprivate:\n\tint m_x, m_y;\n\tmutable int var;\npublic:\n\t\tint getX() const {\n\t\t  var =2;   //这里其实不允许改变的  可以用mutable去修饰var \n\t\t  return m_x; \n\t    }\n}\n\n内存自己操作  操作符operator自定义  灵活\n\n运算符重载    bool operator==const(Vector2& other) const    俩个类相等\n\t\t\t\t{\n\t\t\t\t\treturn x==other.x && y=other.y;\n\t\t\t\t}\n\t使用:  Vector2 result1; Vector2 result2;  if(result1==result2) { } \n    \n\nTrack MEMORY ALLOCATIONS  就是重载关键字  然后把里面的东西弄出来  强的一批  和java反射一样 \n\t\tvoid* operator new(size_t size)\n\t\t{\n\t\t\tstd::cout<<\"allocating \"<<size<<\" bytes\\n\";\n\t\t\treturn malloc(size);\n\t\t}\n\n\t\tvoid operator delete(void* memory, size_t size)\n\t\t{\n\t\t\tstd::cout<<\"freeing \"<<size<<\" bytes\\n\";\n\t\t\tfree(memory);\n\t\t}\n        \n\nauto   自动推导类型  如果是string int 基础 不要用  复杂的 写起来很长的就用 代码非常简洁  例如array迭代器 \n\t\tstd::vector<std::string>::iterator it = strings::begin();    =>  auto it = strings.begin();\n\n\nMacros  宏定义 define  替换字符串   就是替换    用 \\ 换行\n\t\t#define LOG(x) std::cout<<x<<std::endl   LOG(\"HELLO\");\n\t\t还能用#if  #else #endif 去做条件适配\n\n \ntemplate   就是泛型  \tArray<std::string, 5> array;  Array<int, 5> array;\n\n\t\t\t\t\t\ttemplate<typename T, int N>\n\t\t\t\t\t\tclass Array\n\t\t\t\t\t\t{\n\t\t\t\t\t\tprivate:\n\t\t\t\t\t\t\tT m_array[N];\n\t\t\t\t\t\tpublic:\n\t\t\t\t\t\t\tint get_size() const {return N;}\n\t\t\t\t\t\t};\n                        \nTiming\t\t#include <cherno>    std::chrono::high_resolution_clock::now()\n\t\t\t统计函数执行时间  用struct放start和end  构造函数初始化start 在析构函数初始化end 打印耗时 \n\t\t\t\t\t\t\t  在需要统计的函数 创建Timer  因为是栈 所以脱离scope就会释放 妙啊 这个设计 \n\n\nThread  线程 \t#include <thread>\tstd::thread worker(hello);  worker.join(); \n\t\t\t\tvoid hello(){ while(true){ std::cout<<\"hello\"<<std::endl;} }             \n```\n* * *\n##### 新特征\n```c++\n#include <optional>  c++17新特征   \n\t\t\t\t\tstd::optional<std::string> ReadFile(const std::string& filepath)\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::ifstream stream(filepath);\n\t\t\t\t\t\tif(stream)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstd::string result;\n\t\t\t\t\t\t\t//read fil\n\t\t\t\t\t\t\tstream.close();\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\t使用:\n\t\t\t\t\tstd::optional<std::string> data = ReadFile(\"\");\n\t\t\t\t\tif(data.has_value()){  }    就能知道文件是否存在 或者打开过 \n                    \nMultiple TYPES of Data in a SINGLE VARIABLE  一个变量保存多个类型数据  c++17新特征 \n\t\t\t\t\t#include <variant>   std::variant<std::string, int> data;\n\t\t\t\t\t\t\t\t\t\t data = \"cherno\"; data=2;\n\t\t\t\t\t\t\t\t\t\t std::get<std::string>(data)   or std::get<int>(data)                    \nstore ANY data     存储任何数据   #include <any>   std::any   c++17新特征 \n\n\n\n```\n* * *\n##### 其他\nusing namespace   最好不用  难调试  特别是大型的项目 \nType Punning\t类型双关\tint a=50;  double value = *(double*)&a;  奇怪的用法  最好别碰 \n断点 有条件的断点  \nBENCHMARKING 工具  测试性能  用之前 类去做  构造函数开始  析构函数结束  用scope {}\ngoogle chrome  tracing  https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\n\n```c++\nstd::asyn\t\t并发  多线程  #include <future>   std::async( std::launch::async, loadmesh(meshes,filepath); )\n\t\t\t\t锁  std::mutex  s_mutex;    std::lock_guard<std::mutex> lock(s_mutex);  \n```\nlvalues and rvalues\t  int i=10;  i=lvalue  10=rvalue   i可以改  10不能改 \nArgument Evaluation Order  参数传递顺序 \t\n\nStatic Analysis   code review 分析哪里写的有问题    用工具  VS自带的也有 \n\n持续集成（Continuous Integration）\tJenkins\t  不管是哪一个持续集成工具，它本质上只不过是一个定时器，时间一到，做你脚本里让它去做的事\n\n看别人的开源代码  然后吸收营养  直到自己也能写出那样骚的代码   用静态分析工具  找到哪些不合理的地方  然后改进\n\n[youtube](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)\n\n[参考手册](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n\n[编译器](https://wandbox.org/)\n\n[书籍](https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th)","slug":"c++_basic","published":1,"updated":"2021-11-08T17:19:32.860Z","_id":"ckvqxeqvb000098pu1ijjbjrv","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"编译流程\"><a href=\"#编译流程\" class=\"headerlink\" title=\"编译流程\"></a>编译流程</h5><p>txt -&gt; compiling + linking -&gt; exe</p>\n<p>compiling  </p>\n<ul>\n<li>c++编译器把文本变成终极格式 -obj     </li>\n<li>pre-process  评估preprocessor语句</li>\n<li>tokenizing 标记解释</li>\n<li>parsing    解析  抽象语法树  -  解释成编译器能懂和处理的语言                          </li>\n<li>编译器把代码转化成const data 或  instructions </li>\n<li>include   -  只是把 .h文件里面的代码copy过来  例如 xx.h只有个 } 然后在main最后一行 用 #include “xx.h” 把}补进来</li>\n<li>#define INTEGER int -  在main可以  INTEGER main(){}  只是替换 </li>\n<li>#if 0 main{}  #endif  根据特定条件包含或剔除代码  就不会执行了</li>\n<li>obj文件里面是二进制  cpu的机器码  可以转为asm可读-汇编指令</li>\n<li>#progma once 只 include一次  和老的写法 { #ifndef  #define  #endif } 一样</li>\n<li>c标准库头文件一般有.h扩展文件  而c++没得</li>\n</ul>\n<p>linker 把cpp编译好的obj串成exe可执行文件 </p>\n<ul>\n<li>找到每个符号和函数的位置 链接在一起</li>\n<li>link error code和compiler error code都不一样的  容易区分</li>\n<li>如果找不到一模一样的 就会报错  相同的名字和签名-返回值和参数相同</li>\n<li>static的函数 被include 只会在内部有效 </li>\n<li>inline的函数 把函数的身体拿过来调用 和copy类似 </li>\n</ul>\n<p>static linking  &amp;  dynamic libraries<br>static发生在编译期间  dynamic发生在runtime       lib是编译时用到的，dll是运行时用到的</p>\n<p>Precompiled Headers   预编译 头文件 改动东西时  编译会很快 尤其时大型项目  二进制  本质是包含一堆其他头文件的头文件<br>                      针对那些不经常改变的东西  用预编译 头文件 </p>\n<hr>\n<h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>内存  堆栈<br>char 1byte<br>short 2byte<br>int 4byte<br>long 4byte<br>long long 8byte<br>float  4byte   5.5f<br>double 8byte    5.5<br>bool   1byte   无法创建1bit的变量类型 内存没法寻址  1byte=8bit<br>数据类型多大根据编译器来的 用sizeof操作符来检查下  返回byte个数<br>为了不搞多个函数 用inline 不用跳内存 push堆栈之类的  嵌套越多 就越慢</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Casting\t\ttype casting 类型转换   隐式转换  例如  <span class=\"keyword\">int</span> a = (<span class=\"keyword\">int</span>) <span class=\"number\">1.34f</span>;   </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t静态转换  stataic_cast&lt;<span class=\"keyword\">int</span>&gt;(value)  </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t动态转换  <span class=\"keyword\">dynamic_cast</span>&lt;Derived*&gt;(base)</span><br><span class=\"line\">动态转换  <span class=\"keyword\">dynamic_cast</span> 如果有效 则返回指针值 否则null   </span><br><span class=\"line\">\t\tRTTI 运行时类型信息 让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型</span><br><span class=\"line\">\t\t可以设置编译器  把这个关掉  再去编译 会得到warning信息  </span><br><span class=\"line\"></span><br><span class=\"line\">strings faster  性能  处理字符串更快\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; name)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\tstring视图 对现有内存 开启一个小窗口  没新对象产生   </span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\tstd::string name </span>= <span class=\"string\">&quot;yan chernikov&quot;</span>; </span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::string_view <span class=\"title\">firstname</span><span class=\"params\">(name.c_str(), <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::string_view <span class=\"title\">lastname</span><span class=\"params\">(name.c_str()+<span class=\"number\">4</span>, <span class=\"number\">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>std::string 会自动扩容  初始化是8个字节  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA STRUCTURES \t   arrays,lists,sets,maps,trees</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> array[<span class=\"number\">5</span>];   <span class=\"keyword\">int</span>* heapArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];    std::array&lt;<span class=\"keyword\">int</span>,5&gt; arrays;  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span>&#123;</span>  <span class=\"keyword\">int</span>* m_Data;  m_Data=(<span class=\"keyword\">int</span>*)<span class=\"built_in\">alloca</span>(size); &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"function\">ITERATORS     <span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;arr.size(); i++)</span>    <span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">int</span> item : arr)</span>     <span class=\"title\">for</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt;::iterator it=arr.begin(); it!=arr.end(); it++)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t  include &lt;unordered_map&gt;\t-&gt;   std::unordered_map&lt;std::string, <span class=\"keyword\">int</span>&gt; map</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">自己写一个vector类  不复制 直接 move push  pop  clear  <span class=\"keyword\">delete</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h5><p>计算机操作的本质是对内存的操作  访问内存可以是地址，起名字或者起小名<br>reference别名 int a=5; int &amp;ref =a; 那么ref就是a的别名<br>void plus(int&amp; a) 不会传参而是传内存地址   比指针要好看和简洁些</p>\n<p>raw pointer   原始指针   smart pointer 智能指针<br>一个指针只是地址  整数 存储内存地址<br>char* buffer = new char[8]<br>char** ptr = &amp;buffer<br>那么 ptr是内存地址  指向buffer的内存地址  然后通过指向buffer的内存地址找到buffer<br>address -&gt;  address -&gt; value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">智能指针\tstd::unique_ptr, std::shared_ptr, std::weak_ptr</span><br><span class=\"line\">\t\t自动申请和释放内存  不要<span class=\"keyword\">new</span>和<span class=\"keyword\">delete</span>   超出scope就释放</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span> </span></span><br><span class=\"line\">\t\tstd::unique_ptr&lt;Eneity&gt; <span class=\"built_in\">eneity</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>());  唯一指针 在scope后就会自动销毁</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;Eneity&gt; eneity = std::make_shared&lt;Eneity&gt;(); <span class=\"comment\">// 引用计数  没用引用就释放  可以复制 共同指向</span></span><br><span class=\"line\">\t\tstd::weak_ptr&lt;Eneity&gt; e0;   e0 = entity;  如果离开了entity的scope  e0也会释放  弱引用        </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambdas\t 和函数指针搭配食用    https:<span class=\"comment\">//en.cppreference.com/w/cpp/language/lambda</span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> lambda = [](<span class=\"keyword\">int</span> value) &#123;std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;value&lt;&lt;std::endl; &#125;;</span><br><span class=\"line\">\t\t  forEach(values, lambda);</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  使用lambda之外的值  四种方式 =  &amp;  a  &amp;a  </span><br><span class=\"line\">\t\t  <span class=\"keyword\">void</span> forEach(<span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;&amp; values, <span class=\"keyword\">const</span> std::function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>(<span class=\"keyword\">int</span>)&gt;&amp; func)&#123;&#125;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> lambda = [=](<span class=\"keyword\">int</span> value) <span class=\"keyword\">mutable</span> &#123;a=<span class=\"number\">5</span>; std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class=\"line\">\t\t  forEach(values, lambda)</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  类似于rxjava里面的filter</span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">int</span> value)&#123;<span class=\"keyword\">return</span> value&gt;<span class=\"number\">3</span>;&#125;);</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t </span><br><span class=\"line\">funtion pointer  函数指针    和python一样  高阶函数  把函数当作参数变量</span><br><span class=\"line\">\t\t定义函数  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HelloWorld</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123; <span class=\"comment\">//打印逻辑 &#125;</span></span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t使用指针 <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*hellofunction)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\t HelloFunction fu = HelloWorld;</span><br><span class=\"line\">\t\t\t\t <span class=\"built_in\">fu</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t定义高阶函数  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(<span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;&amp; values, <span class=\"keyword\">void</span>(*func)(<span class=\"keyword\">int</span>))</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t  </span>&#123;  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> item : values)  <span class=\"built_in\">func</span>(item); &#125;</span><br><span class=\"line\">\t\t使用 \t\tstd::vector&lt;<span class=\"keyword\">int</span>&gt; values = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125; </span><br><span class=\"line\">\t\t\t\t\tforEach(values, HelloWorld)</span><br><span class=\"line\">\t\t\t\t\t或者内部函数写法  forEach(values, [](<span class=\"keyword\">int</span> value)&#123; std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;std::endl; &#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">Union  类似于别名    在Vector4，去改变x就相当于改变a </span><br><span class=\"line\">Vector2&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vector4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">float</span> x,y,z,w;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t\t\tVector2 a,b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"OOP\"><a href=\"#OOP\" class=\"headerlink\" title=\"OOP\"></a>OOP</h5><p>OOP   面向对象  –  面向过程，基于对象，面向对象，泛型编程<br>extern  在外部寻找<br>static 只执行初始化一次 只会在你声明的那个c++文件是可见的  extern 外部声明也不可以 </p>\n<p>构造函数 析构函数  Eneity() +   ~Eneity() =&gt;  Eneity e;<br>继承: : public Eneity<br>virtual fun虚函数:  允许覆盖子类中的方法   如果要想实现多态 父类必须是虚函数 子类才能覆盖<br> 俩个时间损耗<br>1.需要额外的内存将信息存储在虚函数表中<br> 2.每次调用需要遍历虚函数表 查看映射的函数<br>现在允许加个 override  std::getName() override {return m_name; }</p>\n<p>pure virtual fun 纯虚函数   像java的interface   virtuan std::string getName() = 0; </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Implicit Conversion  隐式转换   <span class=\"keyword\">explicit</span> 关键字  构造函数 </span><br><span class=\"line\">\t隐式转换  构造函数 <span class=\"built_in\">Entity</span>(<span class=\"keyword\">const</span> std::string&amp; name)</span><br><span class=\"line\">\t\t\t\t\t\t\t: <span class=\"built_in\">m_name</span>(name), <span class=\"built_in\">m_age</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"built_in\">Entity</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t\t\t\t\t\t\t: <span class=\"built_in\">m_name</span>(<span class=\"string\">&quot;unknow&quot;</span>), <span class=\"built_in\">m_age</span>(age) &#123;&#125;</span><br><span class=\"line\">\t调用的时候  直接      Entity a = <span class=\"string\">&quot;CHERNO&quot;</span>; 或者  Entity b = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t这会去调用构造函数 和 Entity a = <span class=\"built_in\">Entity</span>(<span class=\"string\">&quot;CHERNO&quot;</span>); 或者  Entity b = <span class=\"built_in\">Entity</span>(<span class=\"number\">22</span>); 一样的效果</span><br><span class=\"line\">\t<span class=\"keyword\">explicit</span> 关键字 就是为了禁止这种奇奇怪怪的东西出现  例</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Entity</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; name)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t\t : m_name(name), m_age(<span class=\"number\">-1</span>) &#123;</span>&#125;</span><br><span class=\"line\">\t\t\t那么 就不能像上面那样玩了   必须 <span class=\"built_in\">Entity</span>(<span class=\"string\">&quot;cherno&quot;</span>); 去实例化对象  </span><br><span class=\"line\"></span><br><span class=\"line\">initializer list：  性能优化 不会创建新的对象 直接赋值 在构造函数中使用  按顺序来 </span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">Entity</span>()</span><br><span class=\"line\">\t\t\t\t\t\t  : <span class=\"built_in\">m_name</span>(<span class=\"string\">&quot;Unknow&quot;</span>), <span class=\"built_in\">m_score</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t &#123;&#125;</span><br><span class=\"line\">                     </span><br><span class=\"line\">对象生命周期 </span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEneity e; <span class=\"comment\">//执行构造函数\t\t\t\t\t如果  Entity* e=new Entity(); </span></span><br><span class=\"line\">\t\t&#125;    \t\t  <span class=\"comment\">//执行析构函数  free memory\t\t// 不会释放 在堆上面创建的实例</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>\t当前对象实例的指针</span><br><span class=\"line\"></span><br><span class=\"line\">箭头  Entity e; e.<span class=\"built_in\">print</span>();  but  Entity* ptr = &amp;e; ptr-&gt;<span class=\"built_in\">print</span>();</span><br><span class=\"line\">\t  操作符重载  更酷的代码    </span><br><span class=\"line\">       </span><br><span class=\"line\">Virtual Destructors\t 虚析构函数\t  父类base 子类derived  </span><br><span class=\"line\">\t\t\t\t\t 如果创建base    父类构造函数 -&gt; 父类析构函数</span><br><span class=\"line\">\t\t\t\t\t 如果创建derived 父类构造函数  子类构造函数 -&gt;  子类析构函数 父类析构函数</span><br><span class=\"line\">\t\t\t\t\t 如果用多态 \t 父类构造函数  子类构造函数 -&gt;  父类析构函数  \t\t======= 不会去执行子类析构函数 内存泄漏maybe</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t 在父类析构函数前面加上  <span class=\"keyword\">virtual</span> 关键字  意味着有可能被扩展  需要调用扩展者的析构函数 </span><br><span class=\"line\">                                     </span><br><span class=\"line\">singletones    在C++中只是将一堆全局变量和静态函数组织起来的方法   牛逼 比java灵活</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>; 删除掉默认的构造函数                                 </span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数多个返回值  \ttuple  \t\t pair   </span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;itility&gt;</span>  #<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span>  函数返回类型=std::tuple<span class=\"meta-string\">&lt;std::string, std::string&gt;</span>   return std::make_pair(s1,s2);</span></span><br><span class=\"line\">\t\t\t或者 <span class=\"class\"><span class=\"keyword\">struct</span>  作为函数 返回多个值  </span></span><br><span class=\"line\"><span class=\"class\">\t\t\t或者对象  也可以 </span></span><br><span class=\"line\"><span class=\"class\">            </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">STRUCTURED</span> <span class=\"title\">BINDINGS</span>  结构化绑定声明  在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t 用<span class=\"title\">tuple</span>  返回多个值 </span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"数组和字符串\"><a href=\"#数组和字符串\" class=\"headerlink\" title=\"数组和字符串\"></a>数组和字符串</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string：  传统的<span class=\"keyword\">char</span>需要以<span class=\"number\">0</span>结尾  才能打印  <span class=\"keyword\">char</span> name[<span class=\"number\">5</span>] = &#123;<span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">0</span>&#125;; </span><br><span class=\"line\">\t\t  用string库   std::string name = <span class=\"string\">&quot;name&quot;</span>;</span><br><span class=\"line\">\t\t  用stdlib.h   <span class=\"keyword\">char</span>=<span class=\"string\">u8&quot;&quot;</span>  <span class=\"keyword\">wchar_t</span>=<span class=\"string\">L&quot;&quot;</span>  <span class=\"keyword\">char16_t</span>=<span class=\"string\">u&quot;&quot;</span>  <span class=\"keyword\">char32_t</span>=<span class=\"string\">U&quot;&quot;</span>    std::u32string   R<span class=\"string\">&quot;&quot;</span>  </span><br><span class=\"line\">\t\t  字符串拼接 <span class=\"string\">&quot;cherno&quot;</span>s + <span class=\"string\">&quot;hello&quot;</span>  或者  std::<span class=\"built_in\">string</span>(<span class=\"string\">&quot;cherno&quot;</span>) + <span class=\"string\">&quot;hello&quot;</span> </span><br><span class=\"line\">          </span><br><span class=\"line\">array:  创建数组</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> arr1[<span class=\"number\">5</span>];     </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span>* arr2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];   <span class=\"keyword\">delete</span>[] arr2;</span><br><span class=\"line\">\t\t\tstd::array&lt;<span class=\"keyword\">int</span>,5&gt; arr3;    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;array&gt;</span></span></span><br><span class=\"line\">            </span><br><span class=\"line\">动态数组 std::vector  不指定大小  会自动扩容  在堆上 </span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span>  std::vector<span class=\"meta-string\">&lt;Entity&gt;</span> arrs;</span></span><br><span class=\"line\">\t\tarrs.<span class=\"function\">push_back    <span class=\"title\">for</span><span class=\"params\">(Entity item : arrs)</span> </span>&#123;&#125;   arrs.<span class=\"built_in\">erase</span>(<span class=\"number\">2</span>)\t\t</span><br><span class=\"line\">\t\tarrs.<span class=\"built_in\">emplace_back</span>() 不要复制 </span><br><span class=\"line\">        </span><br><span class=\"line\">sorting\t\tstd::sort  </span><br><span class=\"line\">\t\t\tstd::vector&lt;<span class=\"keyword\">int</span>&gt; values = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">sort</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">sort</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Multidimensional Arrays  多维数组 </span><br><span class=\"line\">\t\t\t考虑内存优化  分配一块紧凑的  设置宽度去赋值  会很快  </span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"操作内存\"><a href=\"#操作内存\" class=\"headerlink\" title=\"操作内存\"></a>操作内存</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建对象  在栈和堆的区别  </span><br><span class=\"line\">\t\t在堆上面   Entity* entity = <span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>(<span class=\"string\">&quot;Cherno&quot;</span>); 必须释放 <span class=\"keyword\">delete</span> entity;</span><br><span class=\"line\">\t\t在栈  Entity e; 默认调用了构造函数  在函数中  生命周期就是函数执行完成的时候</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">new</span>   在堆上面分配内存  要手动释放\t</span><br><span class=\"line\">\tEntity* e = <span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>();    调用了构造函数</span><br><span class=\"line\">\tEntity* e = (Entity*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">siizeof</span>(Entity));  只是存粹的分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">copy 复制  c++里面的复制和java相反  <span class=\"keyword\">int</span> a=<span class=\"number\">2</span>; <span class=\"keyword\">int</span> b=a; 其实b会copy到a  改变b 不会影响a</span><br><span class=\"line\">\t  用指针的话 就不一样  在堆  指向的是内存  </span><br><span class=\"line\">\t  <span class=\"built_in\">memcpy</span>() 复制字符串 </span><br><span class=\"line\">\t  在对象里面  用运算符重载  真的好看  例如  <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> index)&#123; <span class=\"keyword\">return</span> m_buffer[index]; &#125;</span><br><span class=\"line\">\t  真正的深拷贝  靠构造函数来  重新在堆上分配内存  复制 memcpy</span><br><span class=\"line\">\t  函数传递引用  不能改变值  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> String&amp; string)</span> </span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move Semantics\t\t移动语义\t当一个函数的参数按值传递时，这就会进行拷贝 </span><br><span class=\"line\">\t\t\t\t\tstd::move、std::forward  避免copy的一种手段    避免内存的重新分配</span><br><span class=\"line\">\t\t\t\t\t右值引用提供了一个暂时的对象 我们可以进行移动  右值引用和移动语义允许我们避免不必要的拷贝</span><br><span class=\"line\">\t\t\t\t\t要移动而不是拷贝右值参数的内容。这就会节省很多的空间</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span> a =<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span>&amp;  lr = a;       <span class=\"comment\">// a 是个变量</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span>&amp;&amp; rv = <span class=\"number\">10</span>;      <span class=\"comment\">// 10 是常量\t</span></span><br><span class=\"line\">\t\t\t\t\tString string = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">String <span class=\"title\">dest</span><span class=\"params\">((String&amp;&amp;)string)</span></span>;   <span class=\"comment\">//move string to dest  no copy </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">String <span class=\"title\">dest</span><span class=\"params\">( std::move(string))</span></span>; <span class=\"comment\">//move string to dest  no copy </span></span><br><span class=\"line\">\t\t\t\t\tString dest = std::<span class=\"built_in\">move</span>(string); <span class=\"comment\">//move string to dest  no copy </span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mutable</span>:  俩种用途   一种是 <span class=\"keyword\">const</span>  另一种是 lambda    英文  sth changeable</span><br><span class=\"line\">\t\t  用<span class=\"keyword\">const</span>修饰的函数 不能改东西  但想改  就用<span class=\"keyword\">mutable</span>去修饰需要改变的变量</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [=]() <span class=\"keyword\">mutable</span>   <span class=\"comment\">// [&amp; =]  -&gt;  &#123;&amp;传递地址&#125;  &#123;=复制值不改变原来的值&#125;</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        std::cout&lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//x = 8  just copy not reference passing  只是复制 会重新new一个 没传递地址 不会改变原值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span>： 修饰变量  全局定义 或者函数传参  sth不变   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_AGE = <span class=\"number\">120</span>;  </span><br><span class=\"line\">\t\t修饰函数 放在后面 里面的东西不能改变  但是可以靠<span class=\"keyword\">mutable</span>来改变</span><br><span class=\"line\">clase Entity&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_x, m_y;</span><br><span class=\"line\">\t<span class=\"keyword\">mutable</span> <span class=\"keyword\">int</span> var;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t  var =<span class=\"number\">2</span>;   <span class=\"comment\">//这里其实不允许改变的  可以用mutable去修饰var </span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> m_x; </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">内存自己操作  操作符<span class=\"keyword\">operator</span>自定义  灵活</span><br><span class=\"line\"></span><br><span class=\"line\">运算符重载    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==<span class=\"built_in\"><span class=\"keyword\">const</span></span>(Vector2&amp; other) <span class=\"keyword\">const</span>    俩个类相等</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> x==other.x &amp;&amp; y=other.y;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t使用:  Vector2 result1; Vector2 result2;  <span class=\"keyword\">if</span>(result1==result2) &#123; &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">Track MEMORY ALLOCATIONS  就是重载关键字  然后把里面的东西弄出来  强的一批  和java反射一样 </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;allocating &quot;</span>&lt;&lt;size&lt;&lt;<span class=\"string\">&quot; bytes\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span>* memory, <span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;freeing &quot;</span>&lt;&lt;size&lt;&lt;<span class=\"string\">&quot; bytes\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(memory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span>   自动推导类型  如果是string <span class=\"keyword\">int</span> 基础 不要用  复杂的 写起来很长的就用 代码非常简洁  例如array迭代器 </span><br><span class=\"line\">\t\tstd::vector&lt;std::string&gt;::iterator it = strings::<span class=\"built_in\">begin</span>();    =&gt;  <span class=\"keyword\">auto</span> it = strings.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Macros  宏定义 define  替换字符串   就是替换    用 \\ 换行</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl   LOG(<span class=\"meta-string\">&quot;HELLO&quot;</span>);</span></span><br><span class=\"line\">\t\t还能用<span class=\"meta\">#<span class=\"meta-keyword\">if</span>  #<span class=\"meta-keyword\">else</span> #<span class=\"meta-keyword\">endif</span> 去做条件适配</span></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span>   就是泛型  \tArray&lt;std::string, <span class=\"number\">5</span>&gt; array;  Array&lt;<span class=\"keyword\">int</span>, <span class=\"number\">5</span>&gt; array;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">int</span> N&gt;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span></span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t&#123;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t\t\t\tT m_array[N];</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> N;&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;;</span><br><span class=\"line\">                        </span><br><span class=\"line\">Timing\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cherno&gt;</span>    std::chrono::high_resolution_clock::now()</span></span><br><span class=\"line\">\t\t\t统计函数执行时间  用<span class=\"class\"><span class=\"keyword\">struct</span>放<span class=\"title\">start</span>和<span class=\"title\">end</span>  构造函数初始化<span class=\"title\">start</span> 在析构函数初始化<span class=\"title\">end</span> 打印耗时 </span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t\t  在需要统计的函数 创建<span class=\"title\">Timer</span>  因为是栈 所以脱离<span class=\"title\">scope</span>就会释放 妙啊 这个设计 </span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Thread</span>  线程 \t#<span class=\"title\">include</span> &lt;</span>thread&gt;\t<span class=\"function\">std::thread <span class=\"title\">worker</span><span class=\"params\">(hello)</span></span>;  worker.<span class=\"built_in\">join</span>(); </span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; std::cout&lt;&lt;<span class=\"string\">&quot;hello&quot;</span>&lt;&lt;std::endl;&#125; &#125;             </span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"新特征\"><a href=\"#新特征\" class=\"headerlink\" title=\"新特征\"></a>新特征</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;optional&gt;</span>  c++17新特征   </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::optional&lt;std::string&gt; <span class=\"title\">ReadFile</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; filepath)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"function\">std::ifstream <span class=\"title\">stream</span><span class=\"params\">(filepath)</span></span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(stream)</span><br><span class=\"line\">\t\t\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tstd::string result;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//read fil</span></span><br><span class=\"line\">\t\t\t\t\t\t\tstream.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t使用:</span><br><span class=\"line\">\t\t\t\t\tstd::optional&lt;std::string&gt; data = <span class=\"built_in\">ReadFile</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(data.<span class=\"built_in\">has_value</span>())&#123;  &#125;    就能知道文件是否存在 或者打开过 </span><br><span class=\"line\">                    </span><br><span class=\"line\">Multiple TYPES of Data in a SINGLE VARIABLE  一个变量保存多个类型数据  c++<span class=\"number\">17</span>新特征 </span><br><span class=\"line\">\t\t\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;variant&gt;</span>   std::variant<span class=\"meta-string\">&lt;std::string, int&gt;</span> data;</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t data = <span class=\"string\">&quot;cherno&quot;</span>; data=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t std::get&lt;std::string&gt;(data)   <span class=\"keyword\">or</span> std::get&lt;<span class=\"keyword\">int</span>&gt;(data)                    </span><br><span class=\"line\">store ANY data     存储任何数据   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;any&gt;</span>   std::any   c++17新特征 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><p>using namespace   最好不用  难调试  特别是大型的项目<br>Type Punning    类型双关    int a=50;  double value = <em>(double</em>)&a;  奇怪的用法  最好别碰<br>断点 有条件的断点<br>BENCHMARKING 工具  测试性能  用之前 类去做  构造函数开始  析构函数结束  用scope {}<br>google chrome  tracing  <a href=\"https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::asyn\t\t并发  多线程  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;future&gt;</span>   std::async( std::launch::async, loadmesh(meshes,filepath); )</span></span><br><span class=\"line\">\t\t\t\t锁  std::mutex  s_mutex;    <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(s_mutex)</span></span>;  </span><br></pre></td></tr></table></figure>\n<p>lvalues and rvalues      int i=10;  i=lvalue  10=rvalue   i可以改  10不能改<br>Argument Evaluation Order  参数传递顺序     </p>\n<p>Static Analysis   code review 分析哪里写的有问题    用工具  VS自带的也有 </p>\n<p>持续集成（Continuous Integration）    Jenkins      不管是哪一个持续集成工具，它本质上只不过是一个定时器，时间一到，做你脚本里让它去做的事</p>\n<p>看别人的开源代码  然后吸收营养  直到自己也能写出那样骚的代码   用静态分析工具  找到哪些不合理的地方  然后改进</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb\">youtube</a></p>\n<p><a href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\">参考手册</a></p>\n<p><a href=\"https://wandbox.org/\">编译器</a></p>\n<p><a href=\"https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th\">书籍</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"向大佬致敬","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"博客搭建基石"}]},{"class_name":"好玩","class_desc":"哇塞的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"/img/bbb.jpg","excerpt":"","more":"<h5 id=\"编译流程\"><a href=\"#编译流程\" class=\"headerlink\" title=\"编译流程\"></a>编译流程</h5><p>txt -&gt; compiling + linking -&gt; exe</p>\n<p>compiling  </p>\n<ul>\n<li>c++编译器把文本变成终极格式 -obj     </li>\n<li>pre-process  评估preprocessor语句</li>\n<li>tokenizing 标记解释</li>\n<li>parsing    解析  抽象语法树  -  解释成编译器能懂和处理的语言                          </li>\n<li>编译器把代码转化成const data 或  instructions </li>\n<li>include   -  只是把 .h文件里面的代码copy过来  例如 xx.h只有个 } 然后在main最后一行 用 #include “xx.h” 把}补进来</li>\n<li>#define INTEGER int -  在main可以  INTEGER main(){}  只是替换 </li>\n<li>#if 0 main{}  #endif  根据特定条件包含或剔除代码  就不会执行了</li>\n<li>obj文件里面是二进制  cpu的机器码  可以转为asm可读-汇编指令</li>\n<li>#progma once 只 include一次  和老的写法 { #ifndef  #define  #endif } 一样</li>\n<li>c标准库头文件一般有.h扩展文件  而c++没得</li>\n</ul>\n<p>linker 把cpp编译好的obj串成exe可执行文件 </p>\n<ul>\n<li>找到每个符号和函数的位置 链接在一起</li>\n<li>link error code和compiler error code都不一样的  容易区分</li>\n<li>如果找不到一模一样的 就会报错  相同的名字和签名-返回值和参数相同</li>\n<li>static的函数 被include 只会在内部有效 </li>\n<li>inline的函数 把函数的身体拿过来调用 和copy类似 </li>\n</ul>\n<p>static linking  &amp;  dynamic libraries<br>static发生在编译期间  dynamic发生在runtime       lib是编译时用到的，dll是运行时用到的</p>\n<p>Precompiled Headers   预编译 头文件 改动东西时  编译会很快 尤其时大型项目  二进制  本质是包含一堆其他头文件的头文件<br>                      针对那些不经常改变的东西  用预编译 头文件 </p>\n<hr>\n<h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>内存  堆栈<br>char 1byte<br>short 2byte<br>int 4byte<br>long 4byte<br>long long 8byte<br>float  4byte   5.5f<br>double 8byte    5.5<br>bool   1byte   无法创建1bit的变量类型 内存没法寻址  1byte=8bit<br>数据类型多大根据编译器来的 用sizeof操作符来检查下  返回byte个数<br>为了不搞多个函数 用inline 不用跳内存 push堆栈之类的  嵌套越多 就越慢</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Casting\t\ttype casting 类型转换   隐式转换  例如  <span class=\"keyword\">int</span> a = (<span class=\"keyword\">int</span>) <span class=\"number\">1.34f</span>;   </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t静态转换  stataic_cast&lt;<span class=\"keyword\">int</span>&gt;(value)  </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t动态转换  <span class=\"keyword\">dynamic_cast</span>&lt;Derived*&gt;(base)</span><br><span class=\"line\">动态转换  <span class=\"keyword\">dynamic_cast</span> 如果有效 则返回指针值 否则null   </span><br><span class=\"line\">\t\tRTTI 运行时类型信息 让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型</span><br><span class=\"line\">\t\t可以设置编译器  把这个关掉  再去编译 会得到warning信息  </span><br><span class=\"line\"></span><br><span class=\"line\">strings faster  性能  处理字符串更快\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printName</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; name)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\tstring视图 对现有内存 开启一个小窗口  没新对象产生   </span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\tstd::string name </span>= <span class=\"string\">&quot;yan chernikov&quot;</span>; </span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::string_view <span class=\"title\">firstname</span><span class=\"params\">(name.c_str(), <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::string_view <span class=\"title\">lastname</span><span class=\"params\">(name.c_str()+<span class=\"number\">4</span>, <span class=\"number\">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>std::string 会自动扩容  初始化是8个字节  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA STRUCTURES \t   arrays,lists,sets,maps,trees</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> array[<span class=\"number\">5</span>];   <span class=\"keyword\">int</span>* heapArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];    std::array&lt;<span class=\"keyword\">int</span>,5&gt; arrays;  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span>&#123;</span>  <span class=\"keyword\">int</span>* m_Data;  m_Data=(<span class=\"keyword\">int</span>*)<span class=\"built_in\">alloca</span>(size); &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"function\">ITERATORS     <span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;arr.size(); i++)</span>    <span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">int</span> item : arr)</span>     <span class=\"title\">for</span><span class=\"params\">(std::vector&lt;<span class=\"keyword\">int</span>&gt;::iterator it=arr.begin(); it!=arr.end(); it++)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t  include &lt;unordered_map&gt;\t-&gt;   std::unordered_map&lt;std::string, <span class=\"keyword\">int</span>&gt; map</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">自己写一个vector类  不复制 直接 move push  pop  clear  <span class=\"keyword\">delete</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h5><p>计算机操作的本质是对内存的操作  访问内存可以是地址，起名字或者起小名<br>reference别名 int a=5; int &amp;ref =a; 那么ref就是a的别名<br>void plus(int&amp; a) 不会传参而是传内存地址   比指针要好看和简洁些</p>\n<p>raw pointer   原始指针   smart pointer 智能指针<br>一个指针只是地址  整数 存储内存地址<br>char* buffer = new char[8]<br>char** ptr = &amp;buffer<br>那么 ptr是内存地址  指向buffer的内存地址  然后通过指向buffer的内存地址找到buffer<br>address -&gt;  address -&gt; value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">智能指针\tstd::unique_ptr, std::shared_ptr, std::weak_ptr</span><br><span class=\"line\">\t\t自动申请和释放内存  不要<span class=\"keyword\">new</span>和<span class=\"keyword\">delete</span>   超出scope就释放</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span> </span></span><br><span class=\"line\">\t\tstd::unique_ptr&lt;Eneity&gt; <span class=\"built_in\">eneity</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>());  唯一指针 在scope后就会自动销毁</span><br><span class=\"line\">\t\tstd::shared_ptr&lt;Eneity&gt; eneity = std::make_shared&lt;Eneity&gt;(); <span class=\"comment\">// 引用计数  没用引用就释放  可以复制 共同指向</span></span><br><span class=\"line\">\t\tstd::weak_ptr&lt;Eneity&gt; e0;   e0 = entity;  如果离开了entity的scope  e0也会释放  弱引用        </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambdas\t 和函数指针搭配食用    https:<span class=\"comment\">//en.cppreference.com/w/cpp/language/lambda</span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> lambda = [](<span class=\"keyword\">int</span> value) &#123;std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;value&lt;&lt;std::endl; &#125;;</span><br><span class=\"line\">\t\t  forEach(values, lambda);</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  使用lambda之外的值  四种方式 =  &amp;  a  &amp;a  </span><br><span class=\"line\">\t\t  <span class=\"keyword\">void</span> forEach(<span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;&amp; values, <span class=\"keyword\">const</span> std::function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>(<span class=\"keyword\">int</span>)&gt;&amp; func)&#123;&#125;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> lambda = [=](<span class=\"keyword\">int</span> value) <span class=\"keyword\">mutable</span> &#123;a=<span class=\"number\">5</span>; std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;a&lt;&lt;std::endl;&#125;;</span><br><span class=\"line\">\t\t  forEach(values, lambda)</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  类似于rxjava里面的filter</span><br><span class=\"line\">\t\t  <span class=\"keyword\">auto</span> it = std::<span class=\"built_in\">find_if</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">int</span> value)&#123;<span class=\"keyword\">return</span> value&gt;<span class=\"number\">3</span>;&#125;);</span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t </span><br><span class=\"line\">funtion pointer  函数指针    和python一样  高阶函数  把函数当作参数变量</span><br><span class=\"line\">\t\t定义函数  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HelloWorld</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span> </span>&#123; <span class=\"comment\">//打印逻辑 &#125;</span></span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t使用指针 <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*hellofunction)</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\t HelloFunction fu = HelloWorld;</span><br><span class=\"line\">\t\t\t\t <span class=\"built_in\">fu</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">\t\t定义高阶函数  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(<span class=\"keyword\">const</span> std::vector&lt;<span class=\"keyword\">int</span>&gt;&amp; values, <span class=\"keyword\">void</span>(*func)(<span class=\"keyword\">int</span>))</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t  </span>&#123;  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> item : values)  <span class=\"built_in\">func</span>(item); &#125;</span><br><span class=\"line\">\t\t使用 \t\tstd::vector&lt;<span class=\"keyword\">int</span>&gt; values = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125; </span><br><span class=\"line\">\t\t\t\t\tforEach(values, HelloWorld)</span><br><span class=\"line\">\t\t\t\t\t或者内部函数写法  forEach(values, [](<span class=\"keyword\">int</span> value)&#123; std::cout&lt;&lt;<span class=\"string\">&quot;value&quot;</span>&lt;&lt;std::endl; &#125;)</span><br><span class=\"line\">                    </span><br><span class=\"line\">Union  类似于别名    在Vector4，去改变x就相当于改变a </span><br><span class=\"line\">Vector2&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vector4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">float</span> x,y,z,w;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">\t\t\tVector2 a,b;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"OOP\"><a href=\"#OOP\" class=\"headerlink\" title=\"OOP\"></a>OOP</h5><p>OOP   面向对象  –  面向过程，基于对象，面向对象，泛型编程<br>extern  在外部寻找<br>static 只执行初始化一次 只会在你声明的那个c++文件是可见的  extern 外部声明也不可以 </p>\n<p>构造函数 析构函数  Eneity() +   ~Eneity() =&gt;  Eneity e;<br>继承: : public Eneity<br>virtual fun虚函数:  允许覆盖子类中的方法   如果要想实现多态 父类必须是虚函数 子类才能覆盖<br> 俩个时间损耗<br>1.需要额外的内存将信息存储在虚函数表中<br> 2.每次调用需要遍历虚函数表 查看映射的函数<br>现在允许加个 override  std::getName() override {return m_name; }</p>\n<p>pure virtual fun 纯虚函数   像java的interface   virtuan std::string getName() = 0; </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Implicit Conversion  隐式转换   <span class=\"keyword\">explicit</span> 关键字  构造函数 </span><br><span class=\"line\">\t隐式转换  构造函数 <span class=\"built_in\">Entity</span>(<span class=\"keyword\">const</span> std::string&amp; name)</span><br><span class=\"line\">\t\t\t\t\t\t\t: <span class=\"built_in\">m_name</span>(name), <span class=\"built_in\">m_age</span>(<span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\">\t\t\t\t\t   <span class=\"built_in\">Entity</span>(<span class=\"keyword\">int</span> age)</span><br><span class=\"line\">\t\t\t\t\t\t\t: <span class=\"built_in\">m_name</span>(<span class=\"string\">&quot;unknow&quot;</span>), <span class=\"built_in\">m_age</span>(age) &#123;&#125;</span><br><span class=\"line\">\t调用的时候  直接      Entity a = <span class=\"string\">&quot;CHERNO&quot;</span>; 或者  Entity b = <span class=\"number\">22</span>;</span><br><span class=\"line\">\t这会去调用构造函数 和 Entity a = <span class=\"built_in\">Entity</span>(<span class=\"string\">&quot;CHERNO&quot;</span>); 或者  Entity b = <span class=\"built_in\">Entity</span>(<span class=\"number\">22</span>); 一样的效果</span><br><span class=\"line\">\t<span class=\"keyword\">explicit</span> 关键字 就是为了禁止这种奇奇怪怪的东西出现  例</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Entity</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; name)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t\t : m_name(name), m_age(<span class=\"number\">-1</span>) &#123;</span>&#125;</span><br><span class=\"line\">\t\t\t那么 就不能像上面那样玩了   必须 <span class=\"built_in\">Entity</span>(<span class=\"string\">&quot;cherno&quot;</span>); 去实例化对象  </span><br><span class=\"line\"></span><br><span class=\"line\">initializer list：  性能优化 不会创建新的对象 直接赋值 在构造函数中使用  按顺序来 </span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">Entity</span>()</span><br><span class=\"line\">\t\t\t\t\t\t  : <span class=\"built_in\">m_name</span>(<span class=\"string\">&quot;Unknow&quot;</span>), <span class=\"built_in\">m_score</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t &#123;&#125;</span><br><span class=\"line\">                     </span><br><span class=\"line\">对象生命周期 </span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tEneity e; <span class=\"comment\">//执行构造函数\t\t\t\t\t如果  Entity* e=new Entity(); </span></span><br><span class=\"line\">\t\t&#125;    \t\t  <span class=\"comment\">//执行析构函数  free memory\t\t// 不会释放 在堆上面创建的实例</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>\t当前对象实例的指针</span><br><span class=\"line\"></span><br><span class=\"line\">箭头  Entity e; e.<span class=\"built_in\">print</span>();  but  Entity* ptr = &amp;e; ptr-&gt;<span class=\"built_in\">print</span>();</span><br><span class=\"line\">\t  操作符重载  更酷的代码    </span><br><span class=\"line\">       </span><br><span class=\"line\">Virtual Destructors\t 虚析构函数\t  父类base 子类derived  </span><br><span class=\"line\">\t\t\t\t\t 如果创建base    父类构造函数 -&gt; 父类析构函数</span><br><span class=\"line\">\t\t\t\t\t 如果创建derived 父类构造函数  子类构造函数 -&gt;  子类析构函数 父类析构函数</span><br><span class=\"line\">\t\t\t\t\t 如果用多态 \t 父类构造函数  子类构造函数 -&gt;  父类析构函数  \t\t======= 不会去执行子类析构函数 内存泄漏maybe</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t 在父类析构函数前面加上  <span class=\"keyword\">virtual</span> 关键字  意味着有可能被扩展  需要调用扩展者的析构函数 </span><br><span class=\"line\">                                     </span><br><span class=\"line\">singletones    在C++中只是将一堆全局变量和静态函数组织起来的方法   牛逼 比java灵活</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">Singleton</span>(<span class=\"keyword\">const</span> Singleton&amp;) = <span class=\"keyword\">delete</span>; 删除掉默认的构造函数                                 </span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数多个返回值  \ttuple  \t\t pair   </span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;itility&gt;</span>  #<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span>  函数返回类型=std::tuple<span class=\"meta-string\">&lt;std::string, std::string&gt;</span>   return std::make_pair(s1,s2);</span></span><br><span class=\"line\">\t\t\t或者 <span class=\"class\"><span class=\"keyword\">struct</span>  作为函数 返回多个值  </span></span><br><span class=\"line\"><span class=\"class\">\t\t\t或者对象  也可以 </span></span><br><span class=\"line\"><span class=\"class\">            </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">STRUCTURED</span> <span class=\"title\">BINDINGS</span>  结构化绑定声明  在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。</span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t 用<span class=\"title\">tuple</span>  返回多个值 </span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"数组和字符串\"><a href=\"#数组和字符串\" class=\"headerlink\" title=\"数组和字符串\"></a>数组和字符串</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string：  传统的<span class=\"keyword\">char</span>需要以<span class=\"number\">0</span>结尾  才能打印  <span class=\"keyword\">char</span> name[<span class=\"number\">5</span>] = &#123;<span class=\"string\">&#x27;n&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;m&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">0</span>&#125;; </span><br><span class=\"line\">\t\t  用string库   std::string name = <span class=\"string\">&quot;name&quot;</span>;</span><br><span class=\"line\">\t\t  用stdlib.h   <span class=\"keyword\">char</span>=<span class=\"string\">u8&quot;&quot;</span>  <span class=\"keyword\">wchar_t</span>=<span class=\"string\">L&quot;&quot;</span>  <span class=\"keyword\">char16_t</span>=<span class=\"string\">u&quot;&quot;</span>  <span class=\"keyword\">char32_t</span>=<span class=\"string\">U&quot;&quot;</span>    std::u32string   R<span class=\"string\">&quot;&quot;</span>  </span><br><span class=\"line\">\t\t  字符串拼接 <span class=\"string\">&quot;cherno&quot;</span>s + <span class=\"string\">&quot;hello&quot;</span>  或者  std::<span class=\"built_in\">string</span>(<span class=\"string\">&quot;cherno&quot;</span>) + <span class=\"string\">&quot;hello&quot;</span> </span><br><span class=\"line\">          </span><br><span class=\"line\">array:  创建数组</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> arr1[<span class=\"number\">5</span>];     </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span>* arr2 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];   <span class=\"keyword\">delete</span>[] arr2;</span><br><span class=\"line\">\t\t\tstd::array&lt;<span class=\"keyword\">int</span>,5&gt; arr3;    <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;array&gt;</span></span></span><br><span class=\"line\">            </span><br><span class=\"line\">动态数组 std::vector  不指定大小  会自动扩容  在堆上 </span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span>  std::vector<span class=\"meta-string\">&lt;Entity&gt;</span> arrs;</span></span><br><span class=\"line\">\t\tarrs.<span class=\"function\">push_back    <span class=\"title\">for</span><span class=\"params\">(Entity item : arrs)</span> </span>&#123;&#125;   arrs.<span class=\"built_in\">erase</span>(<span class=\"number\">2</span>)\t\t</span><br><span class=\"line\">\t\tarrs.<span class=\"built_in\">emplace_back</span>() 不要复制 </span><br><span class=\"line\">        </span><br><span class=\"line\">sorting\t\tstd::sort  </span><br><span class=\"line\">\t\t\tstd::vector&lt;<span class=\"keyword\">int</span>&gt; values = &#123;<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">sort</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">sort</span>(values.<span class=\"built_in\">begin</span>(), values.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Multidimensional Arrays  多维数组 </span><br><span class=\"line\">\t\t\t考虑内存优化  分配一块紧凑的  设置宽度去赋值  会很快  </span><br><span class=\"line\">            </span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"操作内存\"><a href=\"#操作内存\" class=\"headerlink\" title=\"操作内存\"></a>操作内存</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建对象  在栈和堆的区别  </span><br><span class=\"line\">\t\t在堆上面   Entity* entity = <span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>(<span class=\"string\">&quot;Cherno&quot;</span>); 必须释放 <span class=\"keyword\">delete</span> entity;</span><br><span class=\"line\">\t\t在栈  Entity e; 默认调用了构造函数  在函数中  生命周期就是函数执行完成的时候</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">new</span>   在堆上面分配内存  要手动释放\t</span><br><span class=\"line\">\tEntity* e = <span class=\"keyword\">new</span> <span class=\"built_in\">Eneity</span>();    调用了构造函数</span><br><span class=\"line\">\tEntity* e = (Entity*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">siizeof</span>(Entity));  只是存粹的分配内存</span><br><span class=\"line\"></span><br><span class=\"line\">copy 复制  c++里面的复制和java相反  <span class=\"keyword\">int</span> a=<span class=\"number\">2</span>; <span class=\"keyword\">int</span> b=a; 其实b会copy到a  改变b 不会影响a</span><br><span class=\"line\">\t  用指针的话 就不一样  在堆  指向的是内存  </span><br><span class=\"line\">\t  <span class=\"built_in\">memcpy</span>() 复制字符串 </span><br><span class=\"line\">\t  在对象里面  用运算符重载  真的好看  例如  <span class=\"keyword\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> index)&#123; <span class=\"keyword\">return</span> m_buffer[index]; &#125;</span><br><span class=\"line\">\t  真正的深拷贝  靠构造函数来  重新在堆上分配内存  复制 memcpy</span><br><span class=\"line\">\t  函数传递引用  不能改变值  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> String&amp; string)</span> </span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move Semantics\t\t移动语义\t当一个函数的参数按值传递时，这就会进行拷贝 </span><br><span class=\"line\">\t\t\t\t\tstd::move、std::forward  避免copy的一种手段    避免内存的重新分配</span><br><span class=\"line\">\t\t\t\t\t右值引用提供了一个暂时的对象 我们可以进行移动  右值引用和移动语义允许我们避免不必要的拷贝</span><br><span class=\"line\">\t\t\t\t\t要移动而不是拷贝右值参数的内容。这就会节省很多的空间</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span> a =<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span>&amp;  lr = a;       <span class=\"comment\">// a 是个变量</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">int</span>&amp;&amp; rv = <span class=\"number\">10</span>;      <span class=\"comment\">// 10 是常量\t</span></span><br><span class=\"line\">\t\t\t\t\tString string = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">String <span class=\"title\">dest</span><span class=\"params\">((String&amp;&amp;)string)</span></span>;   <span class=\"comment\">//move string to dest  no copy </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">String <span class=\"title\">dest</span><span class=\"params\">( std::move(string))</span></span>; <span class=\"comment\">//move string to dest  no copy </span></span><br><span class=\"line\">\t\t\t\t\tString dest = std::<span class=\"built_in\">move</span>(string); <span class=\"comment\">//move string to dest  no copy </span></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mutable</span>:  俩种用途   一种是 <span class=\"keyword\">const</span>  另一种是 lambda    英文  sth changeable</span><br><span class=\"line\">\t\t  用<span class=\"keyword\">const</span>修饰的函数 不能改东西  但想改  就用<span class=\"keyword\">mutable</span>去修饰需要改变的变量</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = [=]() <span class=\"keyword\">mutable</span>   <span class=\"comment\">// [&amp; =]  -&gt;  &#123;&amp;传递地址&#125;  &#123;=复制值不改变原来的值&#125;</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x++;</span><br><span class=\"line\">        std::cout&lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//x = 8  just copy not reference passing  只是复制 会重新new一个 没传递地址 不会改变原值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span>： 修饰变量  全局定义 或者函数传参  sth不变   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_AGE = <span class=\"number\">120</span>;  </span><br><span class=\"line\">\t\t修饰函数 放在后面 里面的东西不能改变  但是可以靠<span class=\"keyword\">mutable</span>来改变</span><br><span class=\"line\">clase Entity&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m_x, m_y;</span><br><span class=\"line\">\t<span class=\"keyword\">mutable</span> <span class=\"keyword\">int</span> var;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getX</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t  var =<span class=\"number\">2</span>;   <span class=\"comment\">//这里其实不允许改变的  可以用mutable去修饰var </span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> m_x; </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">内存自己操作  操作符<span class=\"keyword\">operator</span>自定义  灵活</span><br><span class=\"line\"></span><br><span class=\"line\">运算符重载    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==<span class=\"built_in\"><span class=\"keyword\">const</span></span>(Vector2&amp; other) <span class=\"keyword\">const</span>    俩个类相等</span><br><span class=\"line\">\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> x==other.x &amp;&amp; y=other.y;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t使用:  Vector2 result1; Vector2 result2;  <span class=\"keyword\">if</span>(result1==result2) &#123; &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">Track MEMORY ALLOCATIONS  就是重载关键字  然后把里面的东西弄出来  强的一批  和java反射一样 </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"keyword\">operator</span> <span class=\"title\">new</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;allocating &quot;</span>&lt;&lt;size&lt;&lt;<span class=\"string\">&quot; bytes\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"keyword\">operator</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span>* memory, <span class=\"keyword\">size_t</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;freeing &quot;</span>&lt;&lt;size&lt;&lt;<span class=\"string\">&quot; bytes\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">free</span>(memory);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span>   自动推导类型  如果是string <span class=\"keyword\">int</span> 基础 不要用  复杂的 写起来很长的就用 代码非常简洁  例如array迭代器 </span><br><span class=\"line\">\t\tstd::vector&lt;std::string&gt;::iterator it = strings::<span class=\"built_in\">begin</span>();    =&gt;  <span class=\"keyword\">auto</span> it = strings.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Macros  宏定义 define  替换字符串   就是替换    用 \\ 换行</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOG(x) std::cout&lt;&lt;x&lt;&lt;std::endl   LOG(<span class=\"meta-string\">&quot;HELLO&quot;</span>);</span></span><br><span class=\"line\">\t\t还能用<span class=\"meta\">#<span class=\"meta-keyword\">if</span>  #<span class=\"meta-keyword\">else</span> #<span class=\"meta-keyword\">endif</span> 去做条件适配</span></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">template</span>   就是泛型  \tArray&lt;std::string, <span class=\"number\">5</span>&gt; array;  Array&lt;<span class=\"keyword\">int</span>, <span class=\"number\">5</span>&gt; array;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">int</span> N&gt;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Array</span></span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t&#123;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t\t\t\t\t\tT m_array[N];</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> N;&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;;</span><br><span class=\"line\">                        </span><br><span class=\"line\">Timing\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cherno&gt;</span>    std::chrono::high_resolution_clock::now()</span></span><br><span class=\"line\">\t\t\t统计函数执行时间  用<span class=\"class\"><span class=\"keyword\">struct</span>放<span class=\"title\">start</span>和<span class=\"title\">end</span>  构造函数初始化<span class=\"title\">start</span> 在析构函数初始化<span class=\"title\">end</span> 打印耗时 </span></span><br><span class=\"line\"><span class=\"class\">\t\t\t\t\t\t\t  在需要统计的函数 创建<span class=\"title\">Timer</span>  因为是栈 所以脱离<span class=\"title\">scope</span>就会释放 妙啊 这个设计 </span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Thread</span>  线程 \t#<span class=\"title\">include</span> &lt;</span>thread&gt;\t<span class=\"function\">std::thread <span class=\"title\">worker</span><span class=\"params\">(hello)</span></span>;  worker.<span class=\"built_in\">join</span>(); </span><br><span class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; std::cout&lt;&lt;<span class=\"string\">&quot;hello&quot;</span>&lt;&lt;std::endl;&#125; &#125;             </span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"新特征\"><a href=\"#新特征\" class=\"headerlink\" title=\"新特征\"></a>新特征</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;optional&gt;</span>  c++17新特征   </span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"function\">std::optional&lt;std::string&gt; <span class=\"title\">ReadFile</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; filepath)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"function\">std::ifstream <span class=\"title\">stream</span><span class=\"params\">(filepath)</span></span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(stream)</span><br><span class=\"line\">\t\t\t\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tstd::string result;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//read fil</span></span><br><span class=\"line\">\t\t\t\t\t\t\tstream.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t使用:</span><br><span class=\"line\">\t\t\t\t\tstd::optional&lt;std::string&gt; data = <span class=\"built_in\">ReadFile</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(data.<span class=\"built_in\">has_value</span>())&#123;  &#125;    就能知道文件是否存在 或者打开过 </span><br><span class=\"line\">                    </span><br><span class=\"line\">Multiple TYPES of Data in a SINGLE VARIABLE  一个变量保存多个类型数据  c++<span class=\"number\">17</span>新特征 </span><br><span class=\"line\">\t\t\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;variant&gt;</span>   std::variant<span class=\"meta-string\">&lt;std::string, int&gt;</span> data;</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t data = <span class=\"string\">&quot;cherno&quot;</span>; data=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t std::get&lt;std::string&gt;(data)   <span class=\"keyword\">or</span> std::get&lt;<span class=\"keyword\">int</span>&gt;(data)                    </span><br><span class=\"line\">store ANY data     存储任何数据   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;any&gt;</span>   std::any   c++17新特征 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><p>using namespace   最好不用  难调试  特别是大型的项目<br>Type Punning    类型双关    int a=50;  double value = <em>(double</em>)&a;  奇怪的用法  最好别碰<br>断点 有条件的断点<br>BENCHMARKING 工具  测试性能  用之前 类去做  构造函数开始  析构函数结束  用scope {}<br>google chrome  tracing  <a href=\"https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::asyn\t\t并发  多线程  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;future&gt;</span>   std::async( std::launch::async, loadmesh(meshes,filepath); )</span></span><br><span class=\"line\">\t\t\t\t锁  std::mutex  s_mutex;    <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(s_mutex)</span></span>;  </span><br></pre></td></tr></table></figure>\n<p>lvalues and rvalues      int i=10;  i=lvalue  10=rvalue   i可以改  10不能改<br>Argument Evaluation Order  参数传递顺序     </p>\n<p>Static Analysis   code review 分析哪里写的有问题    用工具  VS自带的也有 </p>\n<p>持续集成（Continuous Integration）    Jenkins      不管是哪一个持续集成工具，它本质上只不过是一个定时器，时间一到，做你脚本里让它去做的事</p>\n<p>看别人的开源代码  然后吸收营养  直到自己也能写出那样骚的代码   用静态分析工具  找到哪些不合理的地方  然后改进</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb\">youtube</a></p>\n<p><a href=\"https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5\">参考手册</a></p>\n<p><a href=\"https://wandbox.org/\">编译器</a></p>\n<p><a href=\"https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th\">书籍</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckvqxeqvb000098pu1ijjbjrv","tag_id":"ckvqxeqvl000198pu9b3s5nq9","_id":"ckvqxj3dl00008kpuduii6nwf"}],"Tag":[{"name":"tools","_id":"ckuptddvs00045opu6v5r7kh2"},{"name":"c++","_id":"ckvqxeqvl000198pu9b3s5nq9"}]}}